{
  "solcInput": {
    "language": "Solidity",
    "sources": {
      "/Users/matt/dev/phaser-platformer/src/contracts/VerletSolver.s.sol": {
        "content": "pragma solidity >=0.8.0;\nimport '/Users/matt/dev/phaser-platformer/src/contracts/ABDKMath64x64.sol';\n\ncontract VerletSolver {\n    struct Vector {\n        int x;\n        int y;\n    }\n\n    struct VectorInt128 {\n        int128 x;\n        int128 y;\n    }\n\n    struct VerletObject {\n        Vector position_current;\n        Vector position_old;\n        Vector acceleration;\n        uint radius;\n    }\n\n    struct Mass {\n        Vector position;\n        int mass;\n        int radius;\n    }\n\n    //a public function that takes in a verlet object and updates its position\n    function updatePosition(VerletObject memory obj, int dt) public pure returns (VerletObject memory) {\n        Vector memory velocity = Vector(\n            obj.position_current.x - obj.position_old.x,\n            obj.position_current.y - obj.position_old.y\n        );\n        obj.position_old = obj.position_current;\n        obj.position_current.x = obj.position_current.x + velocity.x + obj.acceleration.x * dt * dt;\n        obj.position_current.y = obj.position_current.y + velocity.y + obj.acceleration.y * dt * dt;\n\n        //obj.acceleration.x = 0;\n        //obj.acceleration.y = 0;\n\n        return obj;\n    }\n\n    function tick(\n        VerletObject memory obj,\n        Mass[] memory bodies,\n        int dt\n    ) public pure returns (VerletObject memory, Vector memory, Mass[] memory) {\n        obj = applyGravity(obj, 1);\n\n        Vector memory contactPoint;\n        bool collision;\n\n        (obj, contactPoint) = applyConstraintsCircularContainer(obj);\n\n        (obj, bodies, collision) = applyConstraintsPachinko(obj, bodies);\n        if(collision) {\n            contactPoint = Vector(-100, -100);\n        }\n        obj = updatePosition(obj, dt);\n\n        return (obj, contactPoint, bodies);\n    }\n\n    function applyGravitationalBodies(\n        VerletObject memory obj,\n        Mass[] memory bodies\n    ) public pure returns (VerletObject memory) {\n        for (uint i = 0; i < bodies.length; i++) {\n            Vector memory bodyPosition = bodies[i].position;\n            int bodyMass = bodies[i].mass;\n\n            int128 posX = ABDKMath64x64.fromInt(obj.position_current.x);\n            int128 posY = ABDKMath64x64.fromInt(obj.position_current.y);\n            int128 centerX = ABDKMath64x64.fromInt(bodyPosition.x);\n            int128 centerY = ABDKMath64x64.fromInt(bodyPosition.y);\n\n            int128 distance = getDistance(posX, posY, centerX, centerX);\n            int128 force = ABDKMath64x64.div(ABDKMath64x64.fromInt(bodyMass), ABDKMath64x64.mul(distance, distance));\n            int128 nX = ABDKMath64x64.div(ABDKMath64x64.sub(centerX, posX), distance);\n            int128 nY = ABDKMath64x64.div(ABDKMath64x64.sub(centerY, posY), distance);\n\n            obj.acceleration.x += ABDKMath64x64.toInt(ABDKMath64x64.mul(force, nX));\n            obj.acceleration.y += ABDKMath64x64.toInt(ABDKMath64x64.mul(force, nY));\n        }\n\n        return obj;\n    }\n\n    function accelerate(VerletObject memory obj, Vector memory acceleration) public pure returns (VerletObject memory) {\n        obj.acceleration.x = acceleration.x;\n        obj.acceleration.y = acceleration.y;\n        return obj;\n    }\n\n    function applyGravity(VerletObject memory obj, int gravity) public pure returns (VerletObject memory) {\n        obj.acceleration.y += gravity;\n        return obj;\n    }\n\n    struct CollisionData64x64 {\n        VectorInt128 pos;\n        VectorInt128 center;\n    }\n\n    struct CollisionAdjustment {\n        int128 newX;\n        int128 newY;\n        int128 nX;\n        int128 nY;\n    }\n\n    function applyConstraintsPachinko(\n        VerletObject memory obj,\n        Mass[] memory pegs     \n    ) public pure returns (VerletObject memory, Mass[] memory, bool) {\n        bool collision = false;\n\n        for (uint i = 0; i < pegs.length; i++) {\n            Vector memory pegPosition = pegs[i].position;\n            uint pegRadius = uint(pegs[i].radius);\n\n            CollisionData64x64 memory collisionData = CollisionData64x64(\n                VectorInt128(ABDKMath64x64.fromInt(obj.position_current.x), ABDKMath64x64.fromInt(obj.position_current.y)),\n                VectorInt128(ABDKMath64x64.fromInt(pegPosition.x), ABDKMath64x64.fromInt(pegPosition.y))\n            );\n\n            uint objRadius = obj.radius;\n            int128 distance = getDistance(collisionData.pos.x, collisionData.pos.y, collisionData.center.x, collisionData.center.y);\n            //If distance of object is less then radius of peg plus radius of object\n            if (distance < ABDKMath64x64.fromUInt(pegRadius + obj.radius) && !collision) {\n                collision = true;\n                //int nX = (obj.position_current.x - center.x) / int(distance);\n                \n                (CollisionAdjustment memory collisionAdjustment) = unstick64x64(\n                    collisionData.center.x,\n                    collisionData.center.y,\n                    collisionData.pos.x,\n                    collisionData.pos.y,\n                    distance,\n                    pegRadius,\n                    objRadius\n                );\n                obj.position_current.x = ABDKMath64x64.toInt(collisionAdjustment.newX);\n                obj.position_current.y = ABDKMath64x64.toInt(collisionAdjustment.newY);\n\n                //Acceleration becomes the normal line of the collision \n                obj.acceleration.x = -ABDKMath64x64.toInt(collisionAdjustment.nX) * int((90 - obj.radius) / 30);\n                obj.acceleration.y = ABDKMath64x64.toInt(collisionAdjustment.nY) - 15;\n\n                //Remove the peg that was hit from the array\n                pegs = removeItem(pegs, i);\n            }\n        }\n        return (obj, pegs, collision);\n    }\n\n    //Given a collision between two objects, return the new position of the object after the collision\n    function unstick64x64(\n        int128 centerX,\n        int128 centerY,\n        int128 posX,\n        int128 posY,\n        int128 distance,\n        uint collisionObjectMass,\n        uint objectRadius\n    ) internal pure returns (CollisionAdjustment memory) {\n        int128 nX = ABDKMath64x64.div(ABDKMath64x64.sub(centerX, posX), distance);\n        int128 nY = ABDKMath64x64.div(ABDKMath64x64.sub(centerY, posY), distance);\n\n        int128 newX = ABDKMath64x64.sub(\n            centerX,\n            ABDKMath64x64.mul(nX, ABDKMath64x64.fromUInt(collisionObjectMass + objectRadius))\n        );\n        int128 newY = ABDKMath64x64.sub(\n            centerY,\n            ABDKMath64x64.mul(nY, ABDKMath64x64.fromUInt(collisionObjectMass + objectRadius))\n        );\n\n        return CollisionAdjustment(newX, newY, nX, nY);\n    }\n\n    function removeItem(Mass[] memory array, uint index) internal pure returns (Mass[] memory) {\n        require(index < array.length, 'Index out of bounds');\n\n        Mass[] memory newArray = new Mass[](array.length);\n\n        for (uint i = 0; i < newArray.length; i++) {\n            if (i != index) {\n                newArray[i] = array[i];\n            }\n        }\n\n        return newArray;\n    }\n\n    //apply constraints using floating point math\n    function applyConstraintsCircularContainer(\n        VerletObject memory obj\n    ) public pure returns (VerletObject memory, Vector memory) {\n        int128 centerX = ABDKMath64x64.fromInt(1280 / 4);\n        int128 centerY = ABDKMath64x64.fromInt(360);\n\n        int128 boundaryRadius = ABDKMath64x64.fromUInt(320);\n        int128 objRadius = ABDKMath64x64.fromUInt(obj.radius);\n\n        int128 posX = ABDKMath64x64.fromInt(obj.position_current.x);\n        int128 posY = ABDKMath64x64.fromInt(obj.position_current.y);\n\n        int128 distance = getDistance(posX, posY, centerX, centerX);\n\n        Vector memory contactPoint;\n        if (distance > ABDKMath64x64.sub(boundaryRadius, objRadius)) {\n            //int nX = (obj.position_current.x - center.x) / int(distance);\n            int128 nX = ABDKMath64x64.div(ABDKMath64x64.sub(centerX, posX), distance);\n            int128 nY = ABDKMath64x64.div(ABDKMath64x64.sub(centerY, posY), distance);\n\n            int128 newX = ABDKMath64x64.sub(\n                centerX,\n                ABDKMath64x64.mul(nX, ABDKMath64x64.sub(boundaryRadius, objRadius))\n            );\n            int128 newY = ABDKMath64x64.sub(\n                centerY,\n                ABDKMath64x64.mul(nY, ABDKMath64x64.sub(boundaryRadius, objRadius))\n            );\n            obj.position_current.x = ABDKMath64x64.toInt(newX);\n            obj.position_current.y = ABDKMath64x64.toInt(newY);\n\n            //Acceleration becomes the normal line of the collision\n\n            obj.acceleration.x = ABDKMath64x64.toInt(nX);\n            obj.acceleration.y = ABDKMath64x64.toInt(nY);\n\n            if (obj.radius <= 10) {\n                obj.radius = obj.radius + 1;\n            } else {\n                obj.radius = obj.radius - 1;\n            }\n\n            contactPoint = Vector(ABDKMath64x64.toInt(posX), ABDKMath64x64.toInt(posY));\n        } else {\n            contactPoint = Vector(0, 0);\n        }\n\n        return (obj, contactPoint);\n    }\n\n    function getDistance(\n        int128 positionX,\n        int128 positionY,\n        int128 centerX,\n        int128 centerY\n    ) public pure returns (int128) {\n        int128 dx = getDistanceOnAxis(positionX, centerX);\n        int128 dy = getDistanceOnAxis(positionY, centerY);\n\n        int128 combined = ABDKMath64x64.add(ABDKMath64x64.mul(dx, dx), ABDKMath64x64.mul(dy, dy));\n        return ABDKMath64x64.sqrt(combined);\n    }\n\n    function getDistanceOnAxis(int128 x1, int128 x2) public pure returns (int128) {\n        int128 dx;\n        if (x1 < x2 && x1 > 0) {\n            dx = ABDKMath64x64.sub(x2, x1);\n        } else if (x1 > x2) {\n            dx = ABDKMath64x64.sub(x1, x2);\n        } else if (x1 < 0) {\n            dx = ABDKMath64x64.add(ABDKMath64x64.abs(x1), x2);\n        }\n        return dx;\n    }\n}\n"
      },
      "/Users/matt/dev/phaser-platformer/src/contracts/ABDKMath64x64.sol": {
        "content": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity >=0.8.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /*\n   * Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /*\n   * Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (x << 64);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    unchecked {\n      return int64 (x >> 64);\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    unchecked {\n      require (x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (int256 (x << 64));\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    unchecked {\n      require (x >= 0);\n      return uint64 (uint128 (x >> 64));\n    }\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    unchecked {\n      int256 result = x >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    unchecked {\n      return int256 (x) << 64;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) + y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) - y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) * y >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    unchecked {\n      if (x == MIN_64x64) {\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n          y <= 0x1000000000000000000000000000000000000000000000000);\n        return -y << 63;\n      } else {\n        bool negativeResult = false;\n        if (x < 0) {\n          x = -x;\n          negativeResult = true;\n        }\n        if (y < 0) {\n          y = -y; // We rely on overflow behavior here\n          negativeResult = !negativeResult;\n        }\n        uint256 absoluteResult = mulu (x, uint256 (y));\n        if (negativeResult) {\n          require (absoluteResult <=\n            0x8000000000000000000000000000000000000000000000000000000000000000);\n          return -int256 (absoluteResult); // We rely on overflow behavior here\n        } else {\n          require (absoluteResult <=\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n          return int256 (absoluteResult);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    unchecked {\n      if (y == 0) return 0;\n\n      require (x >= 0);\n\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\n\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      hi <<= 64;\n\n      require (hi <=\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n      return hi + lo;\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      int256 result = (int256 (x) << 64) / y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x; // We rely on overflow behavior here\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <= 0x80000000000000000000000000000000);\n        return -int128 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128 (absoluteResult); // We rely on overflow behavior here\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      uint128 result = divuu (x, y);\n      require (result <= uint128 (MAX_64x64));\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return -x;\n    }\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return x < 0 ? -x : x;\n    }\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != 0);\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      return int128 ((int256 (x) + int256 (y)) >> 1);\n    }\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 m = int256 (x) * int256 (y);\n      require (m >= 0);\n      require (m <\n          0x4000000000000000000000000000000000000000000000000000000000000000);\n      return int128 (sqrtu (uint256 (m)));\n    }\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      bool negative = x < 0 && y & 1 == 1;\n\n      uint256 absX = uint128 (x < 0 ? -x : x);\n      uint256 absResult;\n      absResult = 0x100000000000000000000000000000000;\n\n      if (absX <= 0x10000000000000000) {\n        absX <<= 63;\n        while (y != 0) {\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x2 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x4 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x8 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          y >>= 4;\n        }\n\n        absResult >>= 64;\n      } else {\n        uint256 absXShift = 63;\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\n\n        uint256 resultShift = 0;\n        while (y != 0) {\n          require (absXShift < 64);\n\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n            resultShift += absXShift;\n            if (absResult > 0x100000000000000000000000000000000) {\n              absResult >>= 1;\n              resultShift += 1;\n            }\n          }\n          absX = absX * absX >> 127;\n          absXShift <<= 1;\n          if (absX >= 0x100000000000000000000000000000000) {\n              absX >>= 1;\n              absXShift += 1;\n          }\n\n          y >>= 1;\n        }\n\n        require (resultShift < 64);\n        absResult >>= 64 - resultShift;\n      }\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= 0);\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      int256 msb = 0;\n      int256 xc = x;\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 result = msb - 64 << 64;\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n        ux *= ux;\n        uint256 b = ux >> 255;\n        ux >>= 127 + b;\n        result += bit * int256 (b);\n      }\n\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      return int128 (int256 (\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\n    }\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      uint256 result = 0x80000000000000000000000000000000;\n\n      if (x & 0x8000000000000000 > 0)\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n      if (x & 0x4000000000000000 > 0)\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n      if (x & 0x2000000000000000 > 0)\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n      if (x & 0x1000000000000000 > 0)\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n      if (x & 0x800000000000000 > 0)\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n      if (x & 0x400000000000000 > 0)\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n      if (x & 0x200000000000000 > 0)\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n      if (x & 0x100000000000000 > 0)\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n      if (x & 0x80000000000000 > 0)\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n      if (x & 0x40000000000000 > 0)\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n      if (x & 0x20000000000000 > 0)\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n      if (x & 0x10000000000000 > 0)\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n      if (x & 0x8000000000000 > 0)\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n      if (x & 0x4000000000000 > 0)\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n      if (x & 0x2000000000000 > 0)\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n      if (x & 0x1000000000000 > 0)\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n      if (x & 0x800000000000 > 0)\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n      if (x & 0x400000000000 > 0)\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n      if (x & 0x200000000000 > 0)\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n      if (x & 0x100000000000 > 0)\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n      if (x & 0x80000000000 > 0)\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n      if (x & 0x40000000000 > 0)\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n      if (x & 0x20000000000 > 0)\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n      if (x & 0x10000000000 > 0)\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n      if (x & 0x8000000000 > 0)\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n      if (x & 0x4000000000 > 0)\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n      if (x & 0x2000000000 > 0)\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n      if (x & 0x1000000000 > 0)\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n      if (x & 0x800000000 > 0)\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n      if (x & 0x400000000 > 0)\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n      if (x & 0x200000000 > 0)\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n      if (x & 0x100000000 > 0)\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n      if (x & 0x80000000 > 0)\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n      if (x & 0x40000000 > 0)\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n      if (x & 0x20000000 > 0)\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n      if (x & 0x10000000 > 0)\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n      if (x & 0x8000000 > 0)\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n      if (x & 0x4000000 > 0)\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n      if (x & 0x2000000 > 0)\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n      if (x & 0x1000000 > 0)\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n      if (x & 0x800000 > 0)\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n      if (x & 0x400000 > 0)\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n      if (x & 0x200000 > 0)\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n      if (x & 0x100000 > 0)\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n      if (x & 0x80000 > 0)\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n      if (x & 0x40000 > 0)\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n      if (x & 0x20000 > 0)\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n      if (x & 0x10000 > 0)\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n      if (x & 0x8000 > 0)\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n      if (x & 0x4000 > 0)\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n      if (x & 0x2000 > 0)\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n      if (x & 0x1000 > 0)\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n      if (x & 0x800 > 0)\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n      if (x & 0x400 > 0)\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n      if (x & 0x200 > 0)\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n      if (x & 0x100 > 0)\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n      if (x & 0x80 > 0)\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n      if (x & 0x40 > 0)\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n      if (x & 0x20 > 0)\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n      if (x & 0x10 > 0)\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n      if (x & 0x8 > 0)\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n      if (x & 0x4 > 0)\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n      if (x & 0x2 > 0)\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n      if (x & 0x1 > 0)\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n      result >>= uint256 (int256 (63 - (x >> 64)));\n      require (result <= uint256 (int256 (MAX_64x64)));\n\n      return int128 (int256 (result));\n    }\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      return exp_2 (\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    unchecked {\n      require (y != 0);\n\n      uint256 result;\n\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        result = (x << 64) / y;\n      else {\n        uint256 msb = 192;\n        uint256 xc = x >> 192;\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 hi = result * (y >> 128);\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 xh = x >> 192;\n        uint256 xl = x << 64;\n\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n        lo = hi << 128;\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n\n        result += xh == hi >> 128 ? xl / y : 1;\n      }\n\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return uint128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x) private pure returns (uint128) {\n    unchecked {\n      if (x == 0) return 0;\n      else {\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n        if (xx >= 0x4) { r <<= 1; }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return uint128 (r < r1 ? r : r1);\n      }\n    }\n  }\n}"
      }
    },
    "settings": {
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "userdoc",
            "evm.bytecode.object",
            "evm.deployedBytecode.object"
          ]
        }
      }
    }
  },
  "solcOutput": {
    "contracts": {
      "/Users/matt/dev/phaser-platformer/src/contracts/ABDKMath64x64.sol": {
        "ABDKMath64x64": {
          "abi": [],
          "evm": {
            "bytecode": {
              "object": "6055604b600b8282823980515f1a607314603f577f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f80fdfea26469706673582212207474897698aef6c26e303b46118c3a40b6577b75c0e8c1cef9ef86fac7f700d164736f6c63430008160033"
            },
            "deployedBytecode": {
              "object": "730000000000000000000000000000000000000000301460806040525f80fdfea26469706673582212207474897698aef6c26e303b46118c3a40b6577b75c0e8c1cef9ef86fac7f700d164736f6c63430008160033"
            }
          },
          "userdoc": {
            "kind": "user",
            "methods": {},
            "notice": "Smart contract library of mathematical functions operating with signed 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is basically a simple fraction whose numerator is signed 128-bit integer and denominator is 2^64.  As long as denominator is always the same, there is no need to store it, thus in Solidity signed 64.64-bit fixed point numbers are represented by int128 type holding only the numerator.",
            "version": 1
          }
        }
      },
      "/Users/matt/dev/phaser-platformer/src/contracts/VerletSolver.s.sol": {
        "VerletSolver": {
          "abi": [
            {
              "inputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "obj",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                }
              ],
              "name": "accelerate",
              "outputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "",
                  "type": "tuple"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "obj",
                  "type": "tuple"
                }
              ],
              "name": "applyConstraintsCircularContainer",
              "outputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "",
                  "type": "tuple"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "obj",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position",
                      "type": "tuple"
                    },
                    {
                      "internalType": "int256",
                      "name": "mass",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "radius",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Mass[]",
                  "name": "pegs",
                  "type": "tuple[]"
                }
              ],
              "name": "applyConstraintsPachinko",
              "outputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position",
                      "type": "tuple"
                    },
                    {
                      "internalType": "int256",
                      "name": "mass",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "radius",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Mass[]",
                  "name": "",
                  "type": "tuple[]"
                },
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "obj",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position",
                      "type": "tuple"
                    },
                    {
                      "internalType": "int256",
                      "name": "mass",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "radius",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Mass[]",
                  "name": "bodies",
                  "type": "tuple[]"
                }
              ],
              "name": "applyGravitationalBodies",
              "outputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "",
                  "type": "tuple"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "obj",
                  "type": "tuple"
                },
                {
                  "internalType": "int256",
                  "name": "gravity",
                  "type": "int256"
                }
              ],
              "name": "applyGravity",
              "outputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "",
                  "type": "tuple"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int128",
                  "name": "positionX",
                  "type": "int128"
                },
                {
                  "internalType": "int128",
                  "name": "positionY",
                  "type": "int128"
                },
                {
                  "internalType": "int128",
                  "name": "centerX",
                  "type": "int128"
                },
                {
                  "internalType": "int128",
                  "name": "centerY",
                  "type": "int128"
                }
              ],
              "name": "getDistance",
              "outputs": [
                {
                  "internalType": "int128",
                  "name": "",
                  "type": "int128"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int128",
                  "name": "x1",
                  "type": "int128"
                },
                {
                  "internalType": "int128",
                  "name": "x2",
                  "type": "int128"
                }
              ],
              "name": "getDistanceOnAxis",
              "outputs": [
                {
                  "internalType": "int128",
                  "name": "",
                  "type": "int128"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "obj",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position",
                      "type": "tuple"
                    },
                    {
                      "internalType": "int256",
                      "name": "mass",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "radius",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Mass[]",
                  "name": "bodies",
                  "type": "tuple[]"
                },
                {
                  "internalType": "int256",
                  "name": "dt",
                  "type": "int256"
                }
              ],
              "name": "tick",
              "outputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position",
                      "type": "tuple"
                    },
                    {
                      "internalType": "int256",
                      "name": "mass",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "radius",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Mass[]",
                  "name": "",
                  "type": "tuple[]"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "obj",
                  "type": "tuple"
                },
                {
                  "internalType": "int256",
                  "name": "dt",
                  "type": "int256"
                }
              ],
              "name": "updatePosition",
              "outputs": [
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_current",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "position_old",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int256",
                          "name": "x",
                          "type": "int256"
                        },
                        {
                          "internalType": "int256",
                          "name": "y",
                          "type": "int256"
                        }
                      ],
                      "internalType": "struct VerletSolver.Vector",
                      "name": "acceleration",
                      "type": "tuple"
                    },
                    {
                      "internalType": "uint256",
                      "name": "radius",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct VerletSolver.VerletObject",
                  "name": "",
                  "type": "tuple"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            }
          ],
          "evm": {
            "bytecode": {
              "object": "608060405234801561000f575f80fd5b50611d308061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610091575f3560e01c80638de8bfa4116100645780638de8bfa414610158578063c25f4be014610188578063cb62d681146101b8578063ea0dad60146101e8578063f075c4d71461021a57610091565b806311a1067714610095578063170cb9fb146100c557806349bb058f146100f5578063699686fe14610127575b5f80fd5b6100af60048036038101906100aa919061121a565b61024a565b6040516100bc9190611267565b60405180910390f35b6100df60048036038101906100da9190611434565b6102c4565b6040516100ec9190611511565b60405180910390f35b61010f600480360381019061010a9190611653565b6102f2565b60405161011e939291906117b0565b60405180910390f35b610141600480360381019061013c91906117ee565b610540565b60405161014f929190611846565b60405180910390f35b610172600480360381019061016d9190611653565b61074e565b60405161017f9190611511565b60405180910390f35b6101a2600480360381019061019d919061186e565b6108c3565b6040516101af9190611511565b60405180910390f35b6101d260048036038101906101cd9190611434565b6108f6565b6040516101df9190611511565b60405180910390f35b61020260048036038101906101fd91906118ad565b6109f2565b6040516102119392919061191b565b60405180910390f35b610234600480360381019061022f9190611959565b610abf565b6040516102419190611267565b60405180910390f35b5f8082600f0b84600f0b12801561026357505f84600f0b135b15610279576102728385610b0f565b90506102ba565b82600f0b84600f0b1315610298576102918484610b0f565b90506102b9565b5f84600f0b12156102b8576102b56102af85610b74565b84610bc1565b90505b5b5b8091505092915050565b6102cc61112d565b8183604001516020018181516102e291906119ea565b9150818152505082905092915050565b6102fa61112d565b60605f805f90505f5b855181101561052e575f8682815181106103205761031f611a2b565b5b60200260200101515f015190505f87838151811061034157610340611a2b565b5b60200260200101516040015190505f604051806040016040528060405180604001604052806103758e5f01515f0151610c26565b600f0b815260200161038d8e5f015160200151610c26565b600f0b815250815260200160405180604001604052806103af875f0151610c26565b600f0b81526020016103c48760200151610c26565b600f0b81525081525090505f8a6060015190505f610400835f01515f0151845f01516020015185602001515f0151866020015160200151610abf565b905061041a8c60600151856104159190611a58565b610c73565b600f0b81600f0b12801561042c575086155b1561051c57600196505f61046184602001515f0151856020015160200151865f01515f0151875f015160200151868a89610c94565b905061046f815f0151610d58565b60070b8d5f01515f01818152505061048a8160200151610d58565b60070b8d5f01516020018181525050601e8d60600151605a6104ac9190611a8b565b6104b69190611aeb565b6104c38260400151610d58565b6104cc90611b27565b60070b6104d99190611b6d565b8d604001515f018181525050600f6104f48260600151610d58565b6104fe9190611be3565b60070b8d6040015160200181815250506105188c88610d68565b9b50505b50505050508080600101915050610303565b50858582935093509350509250925092565b61054861112d565b610550611166565b5f61055c610140610c26565b90505f61056a610168610c26565b90505f610578610140610c73565b90505f6105888760600151610c73565b90505f61059a885f01515f0151610c26565b90505f6105ad895f015160200151610c26565b90505f6105bc8383898a610abf565b90506105c6611166565b6105d08686610b0f565b600f0b82600f0b1315610723575f6105f16105eb8a87610b0f565b84610e69565b90505f6106076106018a87610b0f565b85610e69565b90505f6106268b6106218561061c8d8d610b0f565b610eee565b610b0f565b90505f6106458b6106408561063b8e8e610b0f565b610eee565b610b0f565b905061065082610d58565b60070b8f5f01515f01818152505061066781610d58565b60070b8f5f0151602001818152505061067f84610d58565b60070b8f604001515f01818152505061069783610d58565b60070b8f604001516020018181525050600a8f60600151116106d25760018f606001516106c49190611a58565b8f60600181815250506106ed565b60018f606001516106e39190611a8b565b8f60600181815250505b60405180604001604052806107018a610d58565b60070b815260200161071289610d58565b60070b81525094505050505061073b565b60405180604001604052805f81526020015f81525090505b8a81995099505050505050505050915091565b61075661112d565b5f5b82518110156108b9575f83828151811061077557610774611a2b565b5b60200260200101515f015190505f84838151811061079657610795611a2b565b5b60200260200101516020015190505f6107b4875f01515f0151610c26565b90505f6107c7885f015160200151610c26565b90505f6107d6855f0151610c26565b90505f6107e68660200151610c26565b90505f6107f585858586610abf565b90505f61081361080488610c26565b61080e8485610eee565b610e69565b90505f6108296108238689610b0f565b84610e69565b90505f61083f6108398689610b0f565b85610e69565b905061085361084e8484610eee565b610d58565b60070b8e604001515f0181815161086a91906119ea565b9150818152505061088361087e8483610eee565b610d58565b60070b8e6040015160200181815161089b91906119ea565b91508181525050505050505050505050508080600101915050610758565b5082905092915050565b6108cb61112d565b815f015183604001515f01818152505081602001518360400151602001818152505082905092915050565b6108fe61112d565b5f604051806040016040528085602001515f0151865f01515f01516109239190611c42565b8152602001856020015160200151865f0151602001516109439190611c42565b8152509050835f01518460200181905250828385604001515f01516109689190611b6d565b6109729190611b6d565b815f0151855f01515f015161098791906119ea565b61099191906119ea565b845f01515f01818152505082838560400151602001516109b19190611b6d565b6109bb9190611b6d565b8160200151855f0151602001516109d291906119ea565b6109dc91906119ea565b845f015160200181815250508391505092915050565b6109fa61112d565b610a02611166565b6060610a0f8660016102c4565b9550610a19611166565b5f610a2388610540565b8093508199505050610a3588886102f2565b809350819950829a505050508015610a9f5760405180604001604052807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c81526020017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c81525091505b610aa988876108f6565b9750878288945094509450505093509350939050565b5f80610acb868561024a565b90505f610ad8868561024a565b90505f610af7610ae88485610eee565b610af28485610eee565b610bc1565b9050610b0281610f57565b9350505050949350505050565b5f8082600f0b84600f0b0390507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610b6257506f7fffffffffffffffffffffffffffffff600f0b8113155b610b6a575f80fd5b8091505092915050565b5f7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b82600f0b03610ba6575f80fd5b5f82600f0b12610bb65781610bba565b815f035b9050919050565b5f8082600f0b84600f0b0190507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610c1457506f7fffffffffffffffffffffffffffffff600f0b8113155b610c1c575f80fd5b8091505092915050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffff80000000000000008212158015610c5f5750677fffffffffffffff8213155b610c67575f80fd5b604082901b9050919050565b5f677fffffffffffffff821115610c88575f80fd5b604082901b9050919050565b610c9c61117e565b5f610cb0610caa8a89610b0f565b86610e69565b90505f610cc6610cc08a89610b0f565b87610e69565b90505f610cef8b610cea85610ce5898b610ce09190611a58565b610c73565b610eee565b610b0f565b90505f610d188b610d1385610d0e8a8c610d099190611a58565b610c73565b610eee565b610b0f565b9050604051806080016040528083600f0b815260200182600f0b815260200185600f0b815260200184600f0b815250945050505050979650505050505050565b5f604082600f0b901d9050919050565b606082518210610dad576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610da490611cdc565b60405180910390fd5b5f835167ffffffffffffffff811115610dc957610dc8611294565b5b604051908082528060200260200182016040528015610e0257816020015b610def6111ae565b815260200190600190039081610de75790505b5090505f5b8151811015610e5e57838114610e5157848181518110610e2a57610e29611a2b565b5b6020026020010151828281518110610e4557610e44611a2b565b5b60200260200101819052505b8080600101915050610e07565b508091505092915050565b5f8082600f0b03610e78575f80fd5b5f82600f0b604085600f0b901b81610e9357610e92611abe565b5b0590507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610edc57506f7fffffffffffffffffffffffffffffff600f0b8113155b610ee4575f80fd5b8091505092915050565b5f80604083600f0b85600f0b02901d90507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610f4557506f7fffffffffffffffffffffffffffffff600f0b8113155b610f4d575f80fd5b8091505092915050565b5f8082600f0b1215610f67575f80fd5b610f77604083600f0b901b610f7e565b9050919050565b5f808203610f8e575f9050611128565b5f8290505f600190507001000000000000000000000000000000008210610fbe57608082901c9150604081901b90505b680100000000000000008210610fdd57604082901c9150602081901b90505b6401000000008210610ff857602082901c9150601081901b90505b62010000821061101157601082901c9150600881901b90505b610100821061102957600882901c9150600481901b90505b6010821061104057600482901c9150600281901b90505b6004821061105057600181901b90505b600181858161106257611061611abe565b5b048201901c9050600181858161107b5761107a611abe565b5b048201901c9050600181858161109457611093611abe565b5b048201901c905060018185816110ad576110ac611abe565b5b048201901c905060018185816110c6576110c5611abe565b5b048201901c905060018185816110df576110de611abe565b5b048201901c905060018185816110f8576110f7611abe565b5b048201901c90505f8185816111105761110f611abe565b5b0490508082106111205780611122565b815b93505050505b919050565b6040518060800160405280611140611166565b815260200161114d611166565b815260200161115a611166565b81526020015f81525090565b60405180604001604052805f81526020015f81525090565b60405180608001604052805f600f0b81526020015f600f0b81526020015f600f0b81526020015f600f0b81525090565b60405180606001604052806111c1611166565b81526020015f81526020015f81525090565b5f604051905090565b5f80fd5b5f80fd5b5f81600f0b9050919050565b6111f9816111e4565b8114611203575f80fd5b50565b5f81359050611214816111f0565b92915050565b5f80604083850312156112305761122f6111dc565b5b5f61123d85828601611206565b925050602061124e85828601611206565b9150509250929050565b611261816111e4565b82525050565b5f60208201905061127a5f830184611258565b92915050565b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6112ca82611284565b810181811067ffffffffffffffff821117156112e9576112e8611294565b5b80604052505050565b5f6112fb6111d3565b905061130782826112c1565b919050565b5f819050919050565b61131e8161130c565b8114611328575f80fd5b50565b5f8135905061133981611315565b92915050565b5f6040828403121561135457611353611280565b5b61135e60406112f2565b90505f61136d8482850161132b565b5f8301525060206113808482850161132b565b60208301525092915050565b5f819050919050565b61139e8161138c565b81146113a8575f80fd5b50565b5f813590506113b981611395565b92915050565b5f60e082840312156113d4576113d3611280565b5b6113de60806112f2565b90505f6113ed8482850161133f565b5f8301525060406114008482850161133f565b60208301525060806114148482850161133f565b60408301525060c0611428848285016113ab565b60608301525092915050565b5f80610100838503121561144b5761144a6111dc565b5b5f611458858286016113bf565b92505060e06114698582860161132b565b9150509250929050565b61147c8161130c565b82525050565b604082015f8201516114965f850182611473565b5060208201516114a96020850182611473565b50505050565b6114b88161138c565b82525050565b60e082015f8201516114d25f850182611482565b5060208201516114e56040850182611482565b5060408201516114f86080850182611482565b50606082015161150b60c08501826114af565b50505050565b5f60e0820190506115245f8301846114be565b92915050565b5f80fd5b5f67ffffffffffffffff82111561154857611547611294565b5b602082029050602081019050919050565b5f80fd5b5f6080828403121561157257611571611280565b5b61157c60606112f2565b90505f61158b8482850161133f565b5f83015250604061159e8482850161132b565b60208301525060606115b28482850161132b565b60408301525092915050565b5f6115d06115cb8461152e565b6112f2565b905080838252602082019050608084028301858111156115f3576115f2611559565b5b835b8181101561161c5780611608888261155d565b8452602084019350506080810190506115f5565b5050509392505050565b5f82601f83011261163a5761163961152a565b5b813561164a8482602086016115be565b91505092915050565b5f80610100838503121561166a576116696111dc565b5b5f611677858286016113bf565b92505060e083013567ffffffffffffffff811115611698576116976111e0565b5b6116a485828601611626565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b608082015f8201516116eb5f850182611482565b5060208201516116fe6040850182611473565b5060408201516117116060850182611473565b50505050565b5f61172283836116d7565b60808301905092915050565b5f602082019050919050565b5f611744826116ae565b61174e81856116b8565b9350611759836116c8565b805f5b838110156117895781516117708882611717565b975061177b8361172e565b92505060018101905061175c565b5085935050505092915050565b5f8115159050919050565b6117aa81611796565b82525050565b5f610120820190506117c45f8301866114be565b81810360e08301526117d6818561173a565b90506117e66101008301846117a1565b949350505050565b5f60e08284031215611803576118026111dc565b5b5f611810848285016113bf565b91505092915050565b604082015f82015161182d5f850182611473565b5060208201516118406020850182611473565b50505050565b5f6101208201905061185a5f8301856114be565b61186760e0830184611819565b9392505050565b5f806101208385031215611885576118846111dc565b5b5f611892858286016113bf565b92505060e06118a38582860161133f565b9150509250929050565b5f805f61012084860312156118c5576118c46111dc565b5b5f6118d2868287016113bf565b93505060e084013567ffffffffffffffff8111156118f3576118f26111e0565b5b6118ff86828701611626565b9250506101006119118682870161132b565b9150509250925092565b5f6101408201905061192f5f8301866114be565b61193c60e0830185611819565b81810361012083015261194f818461173a565b9050949350505050565b5f805f8060808587031215611971576119706111dc565b5b5f61197e87828801611206565b945050602061198f87828801611206565b93505060406119a087828801611206565b92505060606119b187828801611206565b91505092959194509250565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6119f48261130c565b91506119ff8361130c565b92508282019050828112155f8312168382125f841215161715611a2557611a246119bd565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f611a628261138c565b9150611a6d8361138c565b9250828201905080821115611a8557611a846119bd565b5b92915050565b5f611a958261138c565b9150611aa08361138c565b9250828203905081811115611ab857611ab76119bd565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f611af58261138c565b9150611b008361138c565b925082611b1057611b0f611abe565b5b828204905092915050565b5f8160070b9050919050565b5f611b3182611b1b565b91507fffffffffffffffffffffffffffffffffffffffffffffffff80000000000000008203611b6357611b626119bd565b5b815f039050919050565b5f611b778261130c565b9150611b828361130c565b9250828202611b908161130c565b91507f800000000000000000000000000000000000000000000000000000000000000084145f84121615611bc757611bc66119bd565b5b8282058414831517611bdc57611bdb6119bd565b5b5092915050565b5f611bed82611b1b565b9150611bf883611b1b565b92508282039050677fffffffffffffff81137fffffffffffffffffffffffffffffffffffffffffffffffff800000000000000082121715611c3c57611c3b6119bd565b5b92915050565b5f611c4c8261130c565b9150611c578361130c565b925082820390508181125f8412168282135f851215161715611c7c57611c7b6119bd565b5b92915050565b5f82825260208201905092915050565b7f496e646578206f7574206f6620626f756e6473000000000000000000000000005f82015250565b5f611cc6601383611c82565b9150611cd182611c92565b602082019050919050565b5f6020820190508181035f830152611cf381611cba565b905091905056fea26469706673582212203199a19f9e376057fd71e884f7483f4a6a7891bdafa101f0e4ea71cf71190cba64736f6c63430008160033"
            },
            "deployedBytecode": {
              "object": "608060405234801561000f575f80fd5b5060043610610091575f3560e01c80638de8bfa4116100645780638de8bfa414610158578063c25f4be014610188578063cb62d681146101b8578063ea0dad60146101e8578063f075c4d71461021a57610091565b806311a1067714610095578063170cb9fb146100c557806349bb058f146100f5578063699686fe14610127575b5f80fd5b6100af60048036038101906100aa919061121a565b61024a565b6040516100bc9190611267565b60405180910390f35b6100df60048036038101906100da9190611434565b6102c4565b6040516100ec9190611511565b60405180910390f35b61010f600480360381019061010a9190611653565b6102f2565b60405161011e939291906117b0565b60405180910390f35b610141600480360381019061013c91906117ee565b610540565b60405161014f929190611846565b60405180910390f35b610172600480360381019061016d9190611653565b61074e565b60405161017f9190611511565b60405180910390f35b6101a2600480360381019061019d919061186e565b6108c3565b6040516101af9190611511565b60405180910390f35b6101d260048036038101906101cd9190611434565b6108f6565b6040516101df9190611511565b60405180910390f35b61020260048036038101906101fd91906118ad565b6109f2565b6040516102119392919061191b565b60405180910390f35b610234600480360381019061022f9190611959565b610abf565b6040516102419190611267565b60405180910390f35b5f8082600f0b84600f0b12801561026357505f84600f0b135b15610279576102728385610b0f565b90506102ba565b82600f0b84600f0b1315610298576102918484610b0f565b90506102b9565b5f84600f0b12156102b8576102b56102af85610b74565b84610bc1565b90505b5b5b8091505092915050565b6102cc61112d565b8183604001516020018181516102e291906119ea565b9150818152505082905092915050565b6102fa61112d565b60605f805f90505f5b855181101561052e575f8682815181106103205761031f611a2b565b5b60200260200101515f015190505f87838151811061034157610340611a2b565b5b60200260200101516040015190505f604051806040016040528060405180604001604052806103758e5f01515f0151610c26565b600f0b815260200161038d8e5f015160200151610c26565b600f0b815250815260200160405180604001604052806103af875f0151610c26565b600f0b81526020016103c48760200151610c26565b600f0b81525081525090505f8a6060015190505f610400835f01515f0151845f01516020015185602001515f0151866020015160200151610abf565b905061041a8c60600151856104159190611a58565b610c73565b600f0b81600f0b12801561042c575086155b1561051c57600196505f61046184602001515f0151856020015160200151865f01515f0151875f015160200151868a89610c94565b905061046f815f0151610d58565b60070b8d5f01515f01818152505061048a8160200151610d58565b60070b8d5f01516020018181525050601e8d60600151605a6104ac9190611a8b565b6104b69190611aeb565b6104c38260400151610d58565b6104cc90611b27565b60070b6104d99190611b6d565b8d604001515f018181525050600f6104f48260600151610d58565b6104fe9190611be3565b60070b8d6040015160200181815250506105188c88610d68565b9b50505b50505050508080600101915050610303565b50858582935093509350509250925092565b61054861112d565b610550611166565b5f61055c610140610c26565b90505f61056a610168610c26565b90505f610578610140610c73565b90505f6105888760600151610c73565b90505f61059a885f01515f0151610c26565b90505f6105ad895f015160200151610c26565b90505f6105bc8383898a610abf565b90506105c6611166565b6105d08686610b0f565b600f0b82600f0b1315610723575f6105f16105eb8a87610b0f565b84610e69565b90505f6106076106018a87610b0f565b85610e69565b90505f6106268b6106218561061c8d8d610b0f565b610eee565b610b0f565b90505f6106458b6106408561063b8e8e610b0f565b610eee565b610b0f565b905061065082610d58565b60070b8f5f01515f01818152505061066781610d58565b60070b8f5f0151602001818152505061067f84610d58565b60070b8f604001515f01818152505061069783610d58565b60070b8f604001516020018181525050600a8f60600151116106d25760018f606001516106c49190611a58565b8f60600181815250506106ed565b60018f606001516106e39190611a8b565b8f60600181815250505b60405180604001604052806107018a610d58565b60070b815260200161071289610d58565b60070b81525094505050505061073b565b60405180604001604052805f81526020015f81525090505b8a81995099505050505050505050915091565b61075661112d565b5f5b82518110156108b9575f83828151811061077557610774611a2b565b5b60200260200101515f015190505f84838151811061079657610795611a2b565b5b60200260200101516020015190505f6107b4875f01515f0151610c26565b90505f6107c7885f015160200151610c26565b90505f6107d6855f0151610c26565b90505f6107e68660200151610c26565b90505f6107f585858586610abf565b90505f61081361080488610c26565b61080e8485610eee565b610e69565b90505f6108296108238689610b0f565b84610e69565b90505f61083f6108398689610b0f565b85610e69565b905061085361084e8484610eee565b610d58565b60070b8e604001515f0181815161086a91906119ea565b9150818152505061088361087e8483610eee565b610d58565b60070b8e6040015160200181815161089b91906119ea565b91508181525050505050505050505050508080600101915050610758565b5082905092915050565b6108cb61112d565b815f015183604001515f01818152505081602001518360400151602001818152505082905092915050565b6108fe61112d565b5f604051806040016040528085602001515f0151865f01515f01516109239190611c42565b8152602001856020015160200151865f0151602001516109439190611c42565b8152509050835f01518460200181905250828385604001515f01516109689190611b6d565b6109729190611b6d565b815f0151855f01515f015161098791906119ea565b61099191906119ea565b845f01515f01818152505082838560400151602001516109b19190611b6d565b6109bb9190611b6d565b8160200151855f0151602001516109d291906119ea565b6109dc91906119ea565b845f015160200181815250508391505092915050565b6109fa61112d565b610a02611166565b6060610a0f8660016102c4565b9550610a19611166565b5f610a2388610540565b8093508199505050610a3588886102f2565b809350819950829a505050508015610a9f5760405180604001604052807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c81526020017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c81525091505b610aa988876108f6565b9750878288945094509450505093509350939050565b5f80610acb868561024a565b90505f610ad8868561024a565b90505f610af7610ae88485610eee565b610af28485610eee565b610bc1565b9050610b0281610f57565b9350505050949350505050565b5f8082600f0b84600f0b0390507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610b6257506f7fffffffffffffffffffffffffffffff600f0b8113155b610b6a575f80fd5b8091505092915050565b5f7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b82600f0b03610ba6575f80fd5b5f82600f0b12610bb65781610bba565b815f035b9050919050565b5f8082600f0b84600f0b0190507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610c1457506f7fffffffffffffffffffffffffffffff600f0b8113155b610c1c575f80fd5b8091505092915050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffff80000000000000008212158015610c5f5750677fffffffffffffff8213155b610c67575f80fd5b604082901b9050919050565b5f677fffffffffffffff821115610c88575f80fd5b604082901b9050919050565b610c9c61117e565b5f610cb0610caa8a89610b0f565b86610e69565b90505f610cc6610cc08a89610b0f565b87610e69565b90505f610cef8b610cea85610ce5898b610ce09190611a58565b610c73565b610eee565b610b0f565b90505f610d188b610d1385610d0e8a8c610d099190611a58565b610c73565b610eee565b610b0f565b9050604051806080016040528083600f0b815260200182600f0b815260200185600f0b815260200184600f0b815250945050505050979650505050505050565b5f604082600f0b901d9050919050565b606082518210610dad576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610da490611cdc565b60405180910390fd5b5f835167ffffffffffffffff811115610dc957610dc8611294565b5b604051908082528060200260200182016040528015610e0257816020015b610def6111ae565b815260200190600190039081610de75790505b5090505f5b8151811015610e5e57838114610e5157848181518110610e2a57610e29611a2b565b5b6020026020010151828281518110610e4557610e44611a2b565b5b60200260200101819052505b8080600101915050610e07565b508091505092915050565b5f8082600f0b03610e78575f80fd5b5f82600f0b604085600f0b901b81610e9357610e92611abe565b5b0590507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610edc57506f7fffffffffffffffffffffffffffffff600f0b8113155b610ee4575f80fd5b8091505092915050565b5f80604083600f0b85600f0b02901d90507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610f4557506f7fffffffffffffffffffffffffffffff600f0b8113155b610f4d575f80fd5b8091505092915050565b5f8082600f0b1215610f67575f80fd5b610f77604083600f0b901b610f7e565b9050919050565b5f808203610f8e575f9050611128565b5f8290505f600190507001000000000000000000000000000000008210610fbe57608082901c9150604081901b90505b680100000000000000008210610fdd57604082901c9150602081901b90505b6401000000008210610ff857602082901c9150601081901b90505b62010000821061101157601082901c9150600881901b90505b610100821061102957600882901c9150600481901b90505b6010821061104057600482901c9150600281901b90505b6004821061105057600181901b90505b600181858161106257611061611abe565b5b048201901c9050600181858161107b5761107a611abe565b5b048201901c9050600181858161109457611093611abe565b5b048201901c905060018185816110ad576110ac611abe565b5b048201901c905060018185816110c6576110c5611abe565b5b048201901c905060018185816110df576110de611abe565b5b048201901c905060018185816110f8576110f7611abe565b5b048201901c90505f8185816111105761110f611abe565b5b0490508082106111205780611122565b815b93505050505b919050565b6040518060800160405280611140611166565b815260200161114d611166565b815260200161115a611166565b81526020015f81525090565b60405180604001604052805f81526020015f81525090565b60405180608001604052805f600f0b81526020015f600f0b81526020015f600f0b81526020015f600f0b81525090565b60405180606001604052806111c1611166565b81526020015f81526020015f81525090565b5f604051905090565b5f80fd5b5f80fd5b5f81600f0b9050919050565b6111f9816111e4565b8114611203575f80fd5b50565b5f81359050611214816111f0565b92915050565b5f80604083850312156112305761122f6111dc565b5b5f61123d85828601611206565b925050602061124e85828601611206565b9150509250929050565b611261816111e4565b82525050565b5f60208201905061127a5f830184611258565b92915050565b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6112ca82611284565b810181811067ffffffffffffffff821117156112e9576112e8611294565b5b80604052505050565b5f6112fb6111d3565b905061130782826112c1565b919050565b5f819050919050565b61131e8161130c565b8114611328575f80fd5b50565b5f8135905061133981611315565b92915050565b5f6040828403121561135457611353611280565b5b61135e60406112f2565b90505f61136d8482850161132b565b5f8301525060206113808482850161132b565b60208301525092915050565b5f819050919050565b61139e8161138c565b81146113a8575f80fd5b50565b5f813590506113b981611395565b92915050565b5f60e082840312156113d4576113d3611280565b5b6113de60806112f2565b90505f6113ed8482850161133f565b5f8301525060406114008482850161133f565b60208301525060806114148482850161133f565b60408301525060c0611428848285016113ab565b60608301525092915050565b5f80610100838503121561144b5761144a6111dc565b5b5f611458858286016113bf565b92505060e06114698582860161132b565b9150509250929050565b61147c8161130c565b82525050565b604082015f8201516114965f850182611473565b5060208201516114a96020850182611473565b50505050565b6114b88161138c565b82525050565b60e082015f8201516114d25f850182611482565b5060208201516114e56040850182611482565b5060408201516114f86080850182611482565b50606082015161150b60c08501826114af565b50505050565b5f60e0820190506115245f8301846114be565b92915050565b5f80fd5b5f67ffffffffffffffff82111561154857611547611294565b5b602082029050602081019050919050565b5f80fd5b5f6080828403121561157257611571611280565b5b61157c60606112f2565b90505f61158b8482850161133f565b5f83015250604061159e8482850161132b565b60208301525060606115b28482850161132b565b60408301525092915050565b5f6115d06115cb8461152e565b6112f2565b905080838252602082019050608084028301858111156115f3576115f2611559565b5b835b8181101561161c5780611608888261155d565b8452602084019350506080810190506115f5565b5050509392505050565b5f82601f83011261163a5761163961152a565b5b813561164a8482602086016115be565b91505092915050565b5f80610100838503121561166a576116696111dc565b5b5f611677858286016113bf565b92505060e083013567ffffffffffffffff811115611698576116976111e0565b5b6116a485828601611626565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b608082015f8201516116eb5f850182611482565b5060208201516116fe6040850182611473565b5060408201516117116060850182611473565b50505050565b5f61172283836116d7565b60808301905092915050565b5f602082019050919050565b5f611744826116ae565b61174e81856116b8565b9350611759836116c8565b805f5b838110156117895781516117708882611717565b975061177b8361172e565b92505060018101905061175c565b5085935050505092915050565b5f8115159050919050565b6117aa81611796565b82525050565b5f610120820190506117c45f8301866114be565b81810360e08301526117d6818561173a565b90506117e66101008301846117a1565b949350505050565b5f60e08284031215611803576118026111dc565b5b5f611810848285016113bf565b91505092915050565b604082015f82015161182d5f850182611473565b5060208201516118406020850182611473565b50505050565b5f6101208201905061185a5f8301856114be565b61186760e0830184611819565b9392505050565b5f806101208385031215611885576118846111dc565b5b5f611892858286016113bf565b92505060e06118a38582860161133f565b9150509250929050565b5f805f61012084860312156118c5576118c46111dc565b5b5f6118d2868287016113bf565b93505060e084013567ffffffffffffffff8111156118f3576118f26111e0565b5b6118ff86828701611626565b9250506101006119118682870161132b565b9150509250925092565b5f6101408201905061192f5f8301866114be565b61193c60e0830185611819565b81810361012083015261194f818461173a565b9050949350505050565b5f805f8060808587031215611971576119706111dc565b5b5f61197e87828801611206565b945050602061198f87828801611206565b93505060406119a087828801611206565b92505060606119b187828801611206565b91505092959194509250565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6119f48261130c565b91506119ff8361130c565b92508282019050828112155f8312168382125f841215161715611a2557611a246119bd565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f611a628261138c565b9150611a6d8361138c565b9250828201905080821115611a8557611a846119bd565b5b92915050565b5f611a958261138c565b9150611aa08361138c565b9250828203905081811115611ab857611ab76119bd565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f611af58261138c565b9150611b008361138c565b925082611b1057611b0f611abe565b5b828204905092915050565b5f8160070b9050919050565b5f611b3182611b1b565b91507fffffffffffffffffffffffffffffffffffffffffffffffff80000000000000008203611b6357611b626119bd565b5b815f039050919050565b5f611b778261130c565b9150611b828361130c565b9250828202611b908161130c565b91507f800000000000000000000000000000000000000000000000000000000000000084145f84121615611bc757611bc66119bd565b5b8282058414831517611bdc57611bdb6119bd565b5b5092915050565b5f611bed82611b1b565b9150611bf883611b1b565b92508282039050677fffffffffffffff81137fffffffffffffffffffffffffffffffffffffffffffffffff800000000000000082121715611c3c57611c3b6119bd565b5b92915050565b5f611c4c8261130c565b9150611c578361130c565b925082820390508181125f8412168282135f851215161715611c7c57611c7b6119bd565b5b92915050565b5f82825260208201905092915050565b7f496e646578206f7574206f6620626f756e6473000000000000000000000000005f82015250565b5f611cc6601383611c82565b9150611cd182611c92565b602082019050919050565b5f6020820190508181035f830152611cf381611cba565b905091905056fea26469706673582212203199a19f9e376057fd71e884f7483f4a6a7891bdafa101f0e4ea71cf71190cba64736f6c63430008160033"
            }
          },
          "userdoc": {
            "kind": "user",
            "methods": {},
            "version": 1
          }
        }
      }
    },
    "errors": [
      {
        "component": "general",
        "errorCode": "1878",
        "formattedMessage": "Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> /Users/matt/dev/phaser-platformer/src/contracts/VerletSolver.s.sol\n\n",
        "message": "SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.",
        "severity": "warning",
        "sourceLocation": {
          "end": -1,
          "file": "/Users/matt/dev/phaser-platformer/src/contracts/VerletSolver.s.sol",
          "start": -1
        },
        "type": "Warning"
      }
    ],
    "sources": {
      "/Users/matt/dev/phaser-platformer/src/contracts/ABDKMath64x64.sol": {
        "id": 0
      },
      "/Users/matt/dev/phaser-platformer/src/contracts/VerletSolver.s.sol": {
        "id": 1
      }
    }
  },
  "artifacts": {
    "VerletSolver": {
      "contractName": "VerletSolver",
      "abi": [
        {
          "inputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "obj",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "x",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "y",
                  "type": "int256"
                }
              ],
              "internalType": "struct VerletSolver.Vector",
              "name": "acceleration",
              "type": "tuple"
            }
          ],
          "name": "accelerate",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "obj",
              "type": "tuple"
            }
          ],
          "name": "applyConstraintsCircularContainer",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "x",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "y",
                  "type": "int256"
                }
              ],
              "internalType": "struct VerletSolver.Vector",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "obj",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position",
                  "type": "tuple"
                },
                {
                  "internalType": "int256",
                  "name": "mass",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "radius",
                  "type": "int256"
                }
              ],
              "internalType": "struct VerletSolver.Mass[]",
              "name": "pegs",
              "type": "tuple[]"
            }
          ],
          "name": "applyConstraintsPachinko",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position",
                  "type": "tuple"
                },
                {
                  "internalType": "int256",
                  "name": "mass",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "radius",
                  "type": "int256"
                }
              ],
              "internalType": "struct VerletSolver.Mass[]",
              "name": "",
              "type": "tuple[]"
            },
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "obj",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position",
                  "type": "tuple"
                },
                {
                  "internalType": "int256",
                  "name": "mass",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "radius",
                  "type": "int256"
                }
              ],
              "internalType": "struct VerletSolver.Mass[]",
              "name": "bodies",
              "type": "tuple[]"
            }
          ],
          "name": "applyGravitationalBodies",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "obj",
              "type": "tuple"
            },
            {
              "internalType": "int256",
              "name": "gravity",
              "type": "int256"
            }
          ],
          "name": "applyGravity",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int128",
              "name": "positionX",
              "type": "int128"
            },
            {
              "internalType": "int128",
              "name": "positionY",
              "type": "int128"
            },
            {
              "internalType": "int128",
              "name": "centerX",
              "type": "int128"
            },
            {
              "internalType": "int128",
              "name": "centerY",
              "type": "int128"
            }
          ],
          "name": "getDistance",
          "outputs": [
            {
              "internalType": "int128",
              "name": "",
              "type": "int128"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int128",
              "name": "x1",
              "type": "int128"
            },
            {
              "internalType": "int128",
              "name": "x2",
              "type": "int128"
            }
          ],
          "name": "getDistanceOnAxis",
          "outputs": [
            {
              "internalType": "int128",
              "name": "",
              "type": "int128"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "obj",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position",
                  "type": "tuple"
                },
                {
                  "internalType": "int256",
                  "name": "mass",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "radius",
                  "type": "int256"
                }
              ],
              "internalType": "struct VerletSolver.Mass[]",
              "name": "bodies",
              "type": "tuple[]"
            },
            {
              "internalType": "int256",
              "name": "dt",
              "type": "int256"
            }
          ],
          "name": "tick",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "x",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "y",
                  "type": "int256"
                }
              ],
              "internalType": "struct VerletSolver.Vector",
              "name": "",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position",
                  "type": "tuple"
                },
                {
                  "internalType": "int256",
                  "name": "mass",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "radius",
                  "type": "int256"
                }
              ],
              "internalType": "struct VerletSolver.Mass[]",
              "name": "",
              "type": "tuple[]"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "obj",
              "type": "tuple"
            },
            {
              "internalType": "int256",
              "name": "dt",
              "type": "int256"
            }
          ],
          "name": "updatePosition",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_current",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "position_old",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "int256",
                      "name": "x",
                      "type": "int256"
                    },
                    {
                      "internalType": "int256",
                      "name": "y",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct VerletSolver.Vector",
                  "name": "acceleration",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "radius",
                  "type": "uint256"
                }
              ],
              "internalType": "struct VerletSolver.VerletObject",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        }
      ],
      "userdoc": {
        "kind": "user",
        "methods": {},
        "version": 1
      },
      "evm": {
        "bytecode": {
          "object": "608060405234801561000f575f80fd5b50611d308061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610091575f3560e01c80638de8bfa4116100645780638de8bfa414610158578063c25f4be014610188578063cb62d681146101b8578063ea0dad60146101e8578063f075c4d71461021a57610091565b806311a1067714610095578063170cb9fb146100c557806349bb058f146100f5578063699686fe14610127575b5f80fd5b6100af60048036038101906100aa919061121a565b61024a565b6040516100bc9190611267565b60405180910390f35b6100df60048036038101906100da9190611434565b6102c4565b6040516100ec9190611511565b60405180910390f35b61010f600480360381019061010a9190611653565b6102f2565b60405161011e939291906117b0565b60405180910390f35b610141600480360381019061013c91906117ee565b610540565b60405161014f929190611846565b60405180910390f35b610172600480360381019061016d9190611653565b61074e565b60405161017f9190611511565b60405180910390f35b6101a2600480360381019061019d919061186e565b6108c3565b6040516101af9190611511565b60405180910390f35b6101d260048036038101906101cd9190611434565b6108f6565b6040516101df9190611511565b60405180910390f35b61020260048036038101906101fd91906118ad565b6109f2565b6040516102119392919061191b565b60405180910390f35b610234600480360381019061022f9190611959565b610abf565b6040516102419190611267565b60405180910390f35b5f8082600f0b84600f0b12801561026357505f84600f0b135b15610279576102728385610b0f565b90506102ba565b82600f0b84600f0b1315610298576102918484610b0f565b90506102b9565b5f84600f0b12156102b8576102b56102af85610b74565b84610bc1565b90505b5b5b8091505092915050565b6102cc61112d565b8183604001516020018181516102e291906119ea565b9150818152505082905092915050565b6102fa61112d565b60605f805f90505f5b855181101561052e575f8682815181106103205761031f611a2b565b5b60200260200101515f015190505f87838151811061034157610340611a2b565b5b60200260200101516040015190505f604051806040016040528060405180604001604052806103758e5f01515f0151610c26565b600f0b815260200161038d8e5f015160200151610c26565b600f0b815250815260200160405180604001604052806103af875f0151610c26565b600f0b81526020016103c48760200151610c26565b600f0b81525081525090505f8a6060015190505f610400835f01515f0151845f01516020015185602001515f0151866020015160200151610abf565b905061041a8c60600151856104159190611a58565b610c73565b600f0b81600f0b12801561042c575086155b1561051c57600196505f61046184602001515f0151856020015160200151865f01515f0151875f015160200151868a89610c94565b905061046f815f0151610d58565b60070b8d5f01515f01818152505061048a8160200151610d58565b60070b8d5f01516020018181525050601e8d60600151605a6104ac9190611a8b565b6104b69190611aeb565b6104c38260400151610d58565b6104cc90611b27565b60070b6104d99190611b6d565b8d604001515f018181525050600f6104f48260600151610d58565b6104fe9190611be3565b60070b8d6040015160200181815250506105188c88610d68565b9b50505b50505050508080600101915050610303565b50858582935093509350509250925092565b61054861112d565b610550611166565b5f61055c610140610c26565b90505f61056a610168610c26565b90505f610578610140610c73565b90505f6105888760600151610c73565b90505f61059a885f01515f0151610c26565b90505f6105ad895f015160200151610c26565b90505f6105bc8383898a610abf565b90506105c6611166565b6105d08686610b0f565b600f0b82600f0b1315610723575f6105f16105eb8a87610b0f565b84610e69565b90505f6106076106018a87610b0f565b85610e69565b90505f6106268b6106218561061c8d8d610b0f565b610eee565b610b0f565b90505f6106458b6106408561063b8e8e610b0f565b610eee565b610b0f565b905061065082610d58565b60070b8f5f01515f01818152505061066781610d58565b60070b8f5f0151602001818152505061067f84610d58565b60070b8f604001515f01818152505061069783610d58565b60070b8f604001516020018181525050600a8f60600151116106d25760018f606001516106c49190611a58565b8f60600181815250506106ed565b60018f606001516106e39190611a8b565b8f60600181815250505b60405180604001604052806107018a610d58565b60070b815260200161071289610d58565b60070b81525094505050505061073b565b60405180604001604052805f81526020015f81525090505b8a81995099505050505050505050915091565b61075661112d565b5f5b82518110156108b9575f83828151811061077557610774611a2b565b5b60200260200101515f015190505f84838151811061079657610795611a2b565b5b60200260200101516020015190505f6107b4875f01515f0151610c26565b90505f6107c7885f015160200151610c26565b90505f6107d6855f0151610c26565b90505f6107e68660200151610c26565b90505f6107f585858586610abf565b90505f61081361080488610c26565b61080e8485610eee565b610e69565b90505f6108296108238689610b0f565b84610e69565b90505f61083f6108398689610b0f565b85610e69565b905061085361084e8484610eee565b610d58565b60070b8e604001515f0181815161086a91906119ea565b9150818152505061088361087e8483610eee565b610d58565b60070b8e6040015160200181815161089b91906119ea565b91508181525050505050505050505050508080600101915050610758565b5082905092915050565b6108cb61112d565b815f015183604001515f01818152505081602001518360400151602001818152505082905092915050565b6108fe61112d565b5f604051806040016040528085602001515f0151865f01515f01516109239190611c42565b8152602001856020015160200151865f0151602001516109439190611c42565b8152509050835f01518460200181905250828385604001515f01516109689190611b6d565b6109729190611b6d565b815f0151855f01515f015161098791906119ea565b61099191906119ea565b845f01515f01818152505082838560400151602001516109b19190611b6d565b6109bb9190611b6d565b8160200151855f0151602001516109d291906119ea565b6109dc91906119ea565b845f015160200181815250508391505092915050565b6109fa61112d565b610a02611166565b6060610a0f8660016102c4565b9550610a19611166565b5f610a2388610540565b8093508199505050610a3588886102f2565b809350819950829a505050508015610a9f5760405180604001604052807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c81526020017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c81525091505b610aa988876108f6565b9750878288945094509450505093509350939050565b5f80610acb868561024a565b90505f610ad8868561024a565b90505f610af7610ae88485610eee565b610af28485610eee565b610bc1565b9050610b0281610f57565b9350505050949350505050565b5f8082600f0b84600f0b0390507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610b6257506f7fffffffffffffffffffffffffffffff600f0b8113155b610b6a575f80fd5b8091505092915050565b5f7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b82600f0b03610ba6575f80fd5b5f82600f0b12610bb65781610bba565b815f035b9050919050565b5f8082600f0b84600f0b0190507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610c1457506f7fffffffffffffffffffffffffffffff600f0b8113155b610c1c575f80fd5b8091505092915050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffff80000000000000008212158015610c5f5750677fffffffffffffff8213155b610c67575f80fd5b604082901b9050919050565b5f677fffffffffffffff821115610c88575f80fd5b604082901b9050919050565b610c9c61117e565b5f610cb0610caa8a89610b0f565b86610e69565b90505f610cc6610cc08a89610b0f565b87610e69565b90505f610cef8b610cea85610ce5898b610ce09190611a58565b610c73565b610eee565b610b0f565b90505f610d188b610d1385610d0e8a8c610d099190611a58565b610c73565b610eee565b610b0f565b9050604051806080016040528083600f0b815260200182600f0b815260200185600f0b815260200184600f0b815250945050505050979650505050505050565b5f604082600f0b901d9050919050565b606082518210610dad576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610da490611cdc565b60405180910390fd5b5f835167ffffffffffffffff811115610dc957610dc8611294565b5b604051908082528060200260200182016040528015610e0257816020015b610def6111ae565b815260200190600190039081610de75790505b5090505f5b8151811015610e5e57838114610e5157848181518110610e2a57610e29611a2b565b5b6020026020010151828281518110610e4557610e44611a2b565b5b60200260200101819052505b8080600101915050610e07565b508091505092915050565b5f8082600f0b03610e78575f80fd5b5f82600f0b604085600f0b901b81610e9357610e92611abe565b5b0590507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610edc57506f7fffffffffffffffffffffffffffffff600f0b8113155b610ee4575f80fd5b8091505092915050565b5f80604083600f0b85600f0b02901d90507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610f4557506f7fffffffffffffffffffffffffffffff600f0b8113155b610f4d575f80fd5b8091505092915050565b5f8082600f0b1215610f67575f80fd5b610f77604083600f0b901b610f7e565b9050919050565b5f808203610f8e575f9050611128565b5f8290505f600190507001000000000000000000000000000000008210610fbe57608082901c9150604081901b90505b680100000000000000008210610fdd57604082901c9150602081901b90505b6401000000008210610ff857602082901c9150601081901b90505b62010000821061101157601082901c9150600881901b90505b610100821061102957600882901c9150600481901b90505b6010821061104057600482901c9150600281901b90505b6004821061105057600181901b90505b600181858161106257611061611abe565b5b048201901c9050600181858161107b5761107a611abe565b5b048201901c9050600181858161109457611093611abe565b5b048201901c905060018185816110ad576110ac611abe565b5b048201901c905060018185816110c6576110c5611abe565b5b048201901c905060018185816110df576110de611abe565b5b048201901c905060018185816110f8576110f7611abe565b5b048201901c90505f8185816111105761110f611abe565b5b0490508082106111205780611122565b815b93505050505b919050565b6040518060800160405280611140611166565b815260200161114d611166565b815260200161115a611166565b81526020015f81525090565b60405180604001604052805f81526020015f81525090565b60405180608001604052805f600f0b81526020015f600f0b81526020015f600f0b81526020015f600f0b81525090565b60405180606001604052806111c1611166565b81526020015f81526020015f81525090565b5f604051905090565b5f80fd5b5f80fd5b5f81600f0b9050919050565b6111f9816111e4565b8114611203575f80fd5b50565b5f81359050611214816111f0565b92915050565b5f80604083850312156112305761122f6111dc565b5b5f61123d85828601611206565b925050602061124e85828601611206565b9150509250929050565b611261816111e4565b82525050565b5f60208201905061127a5f830184611258565b92915050565b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6112ca82611284565b810181811067ffffffffffffffff821117156112e9576112e8611294565b5b80604052505050565b5f6112fb6111d3565b905061130782826112c1565b919050565b5f819050919050565b61131e8161130c565b8114611328575f80fd5b50565b5f8135905061133981611315565b92915050565b5f6040828403121561135457611353611280565b5b61135e60406112f2565b90505f61136d8482850161132b565b5f8301525060206113808482850161132b565b60208301525092915050565b5f819050919050565b61139e8161138c565b81146113a8575f80fd5b50565b5f813590506113b981611395565b92915050565b5f60e082840312156113d4576113d3611280565b5b6113de60806112f2565b90505f6113ed8482850161133f565b5f8301525060406114008482850161133f565b60208301525060806114148482850161133f565b60408301525060c0611428848285016113ab565b60608301525092915050565b5f80610100838503121561144b5761144a6111dc565b5b5f611458858286016113bf565b92505060e06114698582860161132b565b9150509250929050565b61147c8161130c565b82525050565b604082015f8201516114965f850182611473565b5060208201516114a96020850182611473565b50505050565b6114b88161138c565b82525050565b60e082015f8201516114d25f850182611482565b5060208201516114e56040850182611482565b5060408201516114f86080850182611482565b50606082015161150b60c08501826114af565b50505050565b5f60e0820190506115245f8301846114be565b92915050565b5f80fd5b5f67ffffffffffffffff82111561154857611547611294565b5b602082029050602081019050919050565b5f80fd5b5f6080828403121561157257611571611280565b5b61157c60606112f2565b90505f61158b8482850161133f565b5f83015250604061159e8482850161132b565b60208301525060606115b28482850161132b565b60408301525092915050565b5f6115d06115cb8461152e565b6112f2565b905080838252602082019050608084028301858111156115f3576115f2611559565b5b835b8181101561161c5780611608888261155d565b8452602084019350506080810190506115f5565b5050509392505050565b5f82601f83011261163a5761163961152a565b5b813561164a8482602086016115be565b91505092915050565b5f80610100838503121561166a576116696111dc565b5b5f611677858286016113bf565b92505060e083013567ffffffffffffffff811115611698576116976111e0565b5b6116a485828601611626565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b608082015f8201516116eb5f850182611482565b5060208201516116fe6040850182611473565b5060408201516117116060850182611473565b50505050565b5f61172283836116d7565b60808301905092915050565b5f602082019050919050565b5f611744826116ae565b61174e81856116b8565b9350611759836116c8565b805f5b838110156117895781516117708882611717565b975061177b8361172e565b92505060018101905061175c565b5085935050505092915050565b5f8115159050919050565b6117aa81611796565b82525050565b5f610120820190506117c45f8301866114be565b81810360e08301526117d6818561173a565b90506117e66101008301846117a1565b949350505050565b5f60e08284031215611803576118026111dc565b5b5f611810848285016113bf565b91505092915050565b604082015f82015161182d5f850182611473565b5060208201516118406020850182611473565b50505050565b5f6101208201905061185a5f8301856114be565b61186760e0830184611819565b9392505050565b5f806101208385031215611885576118846111dc565b5b5f611892858286016113bf565b92505060e06118a38582860161133f565b9150509250929050565b5f805f61012084860312156118c5576118c46111dc565b5b5f6118d2868287016113bf565b93505060e084013567ffffffffffffffff8111156118f3576118f26111e0565b5b6118ff86828701611626565b9250506101006119118682870161132b565b9150509250925092565b5f6101408201905061192f5f8301866114be565b61193c60e0830185611819565b81810361012083015261194f818461173a565b9050949350505050565b5f805f8060808587031215611971576119706111dc565b5b5f61197e87828801611206565b945050602061198f87828801611206565b93505060406119a087828801611206565b92505060606119b187828801611206565b91505092959194509250565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6119f48261130c565b91506119ff8361130c565b92508282019050828112155f8312168382125f841215161715611a2557611a246119bd565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f611a628261138c565b9150611a6d8361138c565b9250828201905080821115611a8557611a846119bd565b5b92915050565b5f611a958261138c565b9150611aa08361138c565b9250828203905081811115611ab857611ab76119bd565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f611af58261138c565b9150611b008361138c565b925082611b1057611b0f611abe565b5b828204905092915050565b5f8160070b9050919050565b5f611b3182611b1b565b91507fffffffffffffffffffffffffffffffffffffffffffffffff80000000000000008203611b6357611b626119bd565b5b815f039050919050565b5f611b778261130c565b9150611b828361130c565b9250828202611b908161130c565b91507f800000000000000000000000000000000000000000000000000000000000000084145f84121615611bc757611bc66119bd565b5b8282058414831517611bdc57611bdb6119bd565b5b5092915050565b5f611bed82611b1b565b9150611bf883611b1b565b92508282039050677fffffffffffffff81137fffffffffffffffffffffffffffffffffffffffffffffffff800000000000000082121715611c3c57611c3b6119bd565b5b92915050565b5f611c4c8261130c565b9150611c578361130c565b925082820390508181125f8412168282135f851215161715611c7c57611c7b6119bd565b5b92915050565b5f82825260208201905092915050565b7f496e646578206f7574206f6620626f756e6473000000000000000000000000005f82015250565b5f611cc6601383611c82565b9150611cd182611c92565b602082019050919050565b5f6020820190508181035f830152611cf381611cba565b905091905056fea26469706673582212203199a19f9e376057fd71e884f7483f4a6a7891bdafa101f0e4ea71cf71190cba64736f6c63430008160033"
        },
        "deployedBytecode": {
          "object": "608060405234801561000f575f80fd5b5060043610610091575f3560e01c80638de8bfa4116100645780638de8bfa414610158578063c25f4be014610188578063cb62d681146101b8578063ea0dad60146101e8578063f075c4d71461021a57610091565b806311a1067714610095578063170cb9fb146100c557806349bb058f146100f5578063699686fe14610127575b5f80fd5b6100af60048036038101906100aa919061121a565b61024a565b6040516100bc9190611267565b60405180910390f35b6100df60048036038101906100da9190611434565b6102c4565b6040516100ec9190611511565b60405180910390f35b61010f600480360381019061010a9190611653565b6102f2565b60405161011e939291906117b0565b60405180910390f35b610141600480360381019061013c91906117ee565b610540565b60405161014f929190611846565b60405180910390f35b610172600480360381019061016d9190611653565b61074e565b60405161017f9190611511565b60405180910390f35b6101a2600480360381019061019d919061186e565b6108c3565b6040516101af9190611511565b60405180910390f35b6101d260048036038101906101cd9190611434565b6108f6565b6040516101df9190611511565b60405180910390f35b61020260048036038101906101fd91906118ad565b6109f2565b6040516102119392919061191b565b60405180910390f35b610234600480360381019061022f9190611959565b610abf565b6040516102419190611267565b60405180910390f35b5f8082600f0b84600f0b12801561026357505f84600f0b135b15610279576102728385610b0f565b90506102ba565b82600f0b84600f0b1315610298576102918484610b0f565b90506102b9565b5f84600f0b12156102b8576102b56102af85610b74565b84610bc1565b90505b5b5b8091505092915050565b6102cc61112d565b8183604001516020018181516102e291906119ea565b9150818152505082905092915050565b6102fa61112d565b60605f805f90505f5b855181101561052e575f8682815181106103205761031f611a2b565b5b60200260200101515f015190505f87838151811061034157610340611a2b565b5b60200260200101516040015190505f604051806040016040528060405180604001604052806103758e5f01515f0151610c26565b600f0b815260200161038d8e5f015160200151610c26565b600f0b815250815260200160405180604001604052806103af875f0151610c26565b600f0b81526020016103c48760200151610c26565b600f0b81525081525090505f8a6060015190505f610400835f01515f0151845f01516020015185602001515f0151866020015160200151610abf565b905061041a8c60600151856104159190611a58565b610c73565b600f0b81600f0b12801561042c575086155b1561051c57600196505f61046184602001515f0151856020015160200151865f01515f0151875f015160200151868a89610c94565b905061046f815f0151610d58565b60070b8d5f01515f01818152505061048a8160200151610d58565b60070b8d5f01516020018181525050601e8d60600151605a6104ac9190611a8b565b6104b69190611aeb565b6104c38260400151610d58565b6104cc90611b27565b60070b6104d99190611b6d565b8d604001515f018181525050600f6104f48260600151610d58565b6104fe9190611be3565b60070b8d6040015160200181815250506105188c88610d68565b9b50505b50505050508080600101915050610303565b50858582935093509350509250925092565b61054861112d565b610550611166565b5f61055c610140610c26565b90505f61056a610168610c26565b90505f610578610140610c73565b90505f6105888760600151610c73565b90505f61059a885f01515f0151610c26565b90505f6105ad895f015160200151610c26565b90505f6105bc8383898a610abf565b90506105c6611166565b6105d08686610b0f565b600f0b82600f0b1315610723575f6105f16105eb8a87610b0f565b84610e69565b90505f6106076106018a87610b0f565b85610e69565b90505f6106268b6106218561061c8d8d610b0f565b610eee565b610b0f565b90505f6106458b6106408561063b8e8e610b0f565b610eee565b610b0f565b905061065082610d58565b60070b8f5f01515f01818152505061066781610d58565b60070b8f5f0151602001818152505061067f84610d58565b60070b8f604001515f01818152505061069783610d58565b60070b8f604001516020018181525050600a8f60600151116106d25760018f606001516106c49190611a58565b8f60600181815250506106ed565b60018f606001516106e39190611a8b565b8f60600181815250505b60405180604001604052806107018a610d58565b60070b815260200161071289610d58565b60070b81525094505050505061073b565b60405180604001604052805f81526020015f81525090505b8a81995099505050505050505050915091565b61075661112d565b5f5b82518110156108b9575f83828151811061077557610774611a2b565b5b60200260200101515f015190505f84838151811061079657610795611a2b565b5b60200260200101516020015190505f6107b4875f01515f0151610c26565b90505f6107c7885f015160200151610c26565b90505f6107d6855f0151610c26565b90505f6107e68660200151610c26565b90505f6107f585858586610abf565b90505f61081361080488610c26565b61080e8485610eee565b610e69565b90505f6108296108238689610b0f565b84610e69565b90505f61083f6108398689610b0f565b85610e69565b905061085361084e8484610eee565b610d58565b60070b8e604001515f0181815161086a91906119ea565b9150818152505061088361087e8483610eee565b610d58565b60070b8e6040015160200181815161089b91906119ea565b91508181525050505050505050505050508080600101915050610758565b5082905092915050565b6108cb61112d565b815f015183604001515f01818152505081602001518360400151602001818152505082905092915050565b6108fe61112d565b5f604051806040016040528085602001515f0151865f01515f01516109239190611c42565b8152602001856020015160200151865f0151602001516109439190611c42565b8152509050835f01518460200181905250828385604001515f01516109689190611b6d565b6109729190611b6d565b815f0151855f01515f015161098791906119ea565b61099191906119ea565b845f01515f01818152505082838560400151602001516109b19190611b6d565b6109bb9190611b6d565b8160200151855f0151602001516109d291906119ea565b6109dc91906119ea565b845f015160200181815250508391505092915050565b6109fa61112d565b610a02611166565b6060610a0f8660016102c4565b9550610a19611166565b5f610a2388610540565b8093508199505050610a3588886102f2565b809350819950829a505050508015610a9f5760405180604001604052807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c81526020017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c81525091505b610aa988876108f6565b9750878288945094509450505093509350939050565b5f80610acb868561024a565b90505f610ad8868561024a565b90505f610af7610ae88485610eee565b610af28485610eee565b610bc1565b9050610b0281610f57565b9350505050949350505050565b5f8082600f0b84600f0b0390507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610b6257506f7fffffffffffffffffffffffffffffff600f0b8113155b610b6a575f80fd5b8091505092915050565b5f7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b82600f0b03610ba6575f80fd5b5f82600f0b12610bb65781610bba565b815f035b9050919050565b5f8082600f0b84600f0b0190507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610c1457506f7fffffffffffffffffffffffffffffff600f0b8113155b610c1c575f80fd5b8091505092915050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffff80000000000000008212158015610c5f5750677fffffffffffffff8213155b610c67575f80fd5b604082901b9050919050565b5f677fffffffffffffff821115610c88575f80fd5b604082901b9050919050565b610c9c61117e565b5f610cb0610caa8a89610b0f565b86610e69565b90505f610cc6610cc08a89610b0f565b87610e69565b90505f610cef8b610cea85610ce5898b610ce09190611a58565b610c73565b610eee565b610b0f565b90505f610d188b610d1385610d0e8a8c610d099190611a58565b610c73565b610eee565b610b0f565b9050604051806080016040528083600f0b815260200182600f0b815260200185600f0b815260200184600f0b815250945050505050979650505050505050565b5f604082600f0b901d9050919050565b606082518210610dad576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610da490611cdc565b60405180910390fd5b5f835167ffffffffffffffff811115610dc957610dc8611294565b5b604051908082528060200260200182016040528015610e0257816020015b610def6111ae565b815260200190600190039081610de75790505b5090505f5b8151811015610e5e57838114610e5157848181518110610e2a57610e29611a2b565b5b6020026020010151828281518110610e4557610e44611a2b565b5b60200260200101819052505b8080600101915050610e07565b508091505092915050565b5f8082600f0b03610e78575f80fd5b5f82600f0b604085600f0b901b81610e9357610e92611abe565b5b0590507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610edc57506f7fffffffffffffffffffffffffffffff600f0b8113155b610ee4575f80fd5b8091505092915050565b5f80604083600f0b85600f0b02901d90507fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8112158015610f4557506f7fffffffffffffffffffffffffffffff600f0b8113155b610f4d575f80fd5b8091505092915050565b5f8082600f0b1215610f67575f80fd5b610f77604083600f0b901b610f7e565b9050919050565b5f808203610f8e575f9050611128565b5f8290505f600190507001000000000000000000000000000000008210610fbe57608082901c9150604081901b90505b680100000000000000008210610fdd57604082901c9150602081901b90505b6401000000008210610ff857602082901c9150601081901b90505b62010000821061101157601082901c9150600881901b90505b610100821061102957600882901c9150600481901b90505b6010821061104057600482901c9150600281901b90505b6004821061105057600181901b90505b600181858161106257611061611abe565b5b048201901c9050600181858161107b5761107a611abe565b5b048201901c9050600181858161109457611093611abe565b5b048201901c905060018185816110ad576110ac611abe565b5b048201901c905060018185816110c6576110c5611abe565b5b048201901c905060018185816110df576110de611abe565b5b048201901c905060018185816110f8576110f7611abe565b5b048201901c90505f8185816111105761110f611abe565b5b0490508082106111205780611122565b815b93505050505b919050565b6040518060800160405280611140611166565b815260200161114d611166565b815260200161115a611166565b81526020015f81525090565b60405180604001604052805f81526020015f81525090565b60405180608001604052805f600f0b81526020015f600f0b81526020015f600f0b81526020015f600f0b81525090565b60405180606001604052806111c1611166565b81526020015f81526020015f81525090565b5f604051905090565b5f80fd5b5f80fd5b5f81600f0b9050919050565b6111f9816111e4565b8114611203575f80fd5b50565b5f81359050611214816111f0565b92915050565b5f80604083850312156112305761122f6111dc565b5b5f61123d85828601611206565b925050602061124e85828601611206565b9150509250929050565b611261816111e4565b82525050565b5f60208201905061127a5f830184611258565b92915050565b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6112ca82611284565b810181811067ffffffffffffffff821117156112e9576112e8611294565b5b80604052505050565b5f6112fb6111d3565b905061130782826112c1565b919050565b5f819050919050565b61131e8161130c565b8114611328575f80fd5b50565b5f8135905061133981611315565b92915050565b5f6040828403121561135457611353611280565b5b61135e60406112f2565b90505f61136d8482850161132b565b5f8301525060206113808482850161132b565b60208301525092915050565b5f819050919050565b61139e8161138c565b81146113a8575f80fd5b50565b5f813590506113b981611395565b92915050565b5f60e082840312156113d4576113d3611280565b5b6113de60806112f2565b90505f6113ed8482850161133f565b5f8301525060406114008482850161133f565b60208301525060806114148482850161133f565b60408301525060c0611428848285016113ab565b60608301525092915050565b5f80610100838503121561144b5761144a6111dc565b5b5f611458858286016113bf565b92505060e06114698582860161132b565b9150509250929050565b61147c8161130c565b82525050565b604082015f8201516114965f850182611473565b5060208201516114a96020850182611473565b50505050565b6114b88161138c565b82525050565b60e082015f8201516114d25f850182611482565b5060208201516114e56040850182611482565b5060408201516114f86080850182611482565b50606082015161150b60c08501826114af565b50505050565b5f60e0820190506115245f8301846114be565b92915050565b5f80fd5b5f67ffffffffffffffff82111561154857611547611294565b5b602082029050602081019050919050565b5f80fd5b5f6080828403121561157257611571611280565b5b61157c60606112f2565b90505f61158b8482850161133f565b5f83015250604061159e8482850161132b565b60208301525060606115b28482850161132b565b60408301525092915050565b5f6115d06115cb8461152e565b6112f2565b905080838252602082019050608084028301858111156115f3576115f2611559565b5b835b8181101561161c5780611608888261155d565b8452602084019350506080810190506115f5565b5050509392505050565b5f82601f83011261163a5761163961152a565b5b813561164a8482602086016115be565b91505092915050565b5f80610100838503121561166a576116696111dc565b5b5f611677858286016113bf565b92505060e083013567ffffffffffffffff811115611698576116976111e0565b5b6116a485828601611626565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b608082015f8201516116eb5f850182611482565b5060208201516116fe6040850182611473565b5060408201516117116060850182611473565b50505050565b5f61172283836116d7565b60808301905092915050565b5f602082019050919050565b5f611744826116ae565b61174e81856116b8565b9350611759836116c8565b805f5b838110156117895781516117708882611717565b975061177b8361172e565b92505060018101905061175c565b5085935050505092915050565b5f8115159050919050565b6117aa81611796565b82525050565b5f610120820190506117c45f8301866114be565b81810360e08301526117d6818561173a565b90506117e66101008301846117a1565b949350505050565b5f60e08284031215611803576118026111dc565b5b5f611810848285016113bf565b91505092915050565b604082015f82015161182d5f850182611473565b5060208201516118406020850182611473565b50505050565b5f6101208201905061185a5f8301856114be565b61186760e0830184611819565b9392505050565b5f806101208385031215611885576118846111dc565b5b5f611892858286016113bf565b92505060e06118a38582860161133f565b9150509250929050565b5f805f61012084860312156118c5576118c46111dc565b5b5f6118d2868287016113bf565b93505060e084013567ffffffffffffffff8111156118f3576118f26111e0565b5b6118ff86828701611626565b9250506101006119118682870161132b565b9150509250925092565b5f6101408201905061192f5f8301866114be565b61193c60e0830185611819565b81810361012083015261194f818461173a565b9050949350505050565b5f805f8060808587031215611971576119706111dc565b5b5f61197e87828801611206565b945050602061198f87828801611206565b93505060406119a087828801611206565b92505060606119b187828801611206565b91505092959194509250565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6119f48261130c565b91506119ff8361130c565b92508282019050828112155f8312168382125f841215161715611a2557611a246119bd565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f611a628261138c565b9150611a6d8361138c565b9250828201905080821115611a8557611a846119bd565b5b92915050565b5f611a958261138c565b9150611aa08361138c565b9250828203905081811115611ab857611ab76119bd565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f611af58261138c565b9150611b008361138c565b925082611b1057611b0f611abe565b5b828204905092915050565b5f8160070b9050919050565b5f611b3182611b1b565b91507fffffffffffffffffffffffffffffffffffffffffffffffff80000000000000008203611b6357611b626119bd565b5b815f039050919050565b5f611b778261130c565b9150611b828361130c565b9250828202611b908161130c565b91507f800000000000000000000000000000000000000000000000000000000000000084145f84121615611bc757611bc66119bd565b5b8282058414831517611bdc57611bdb6119bd565b5b5092915050565b5f611bed82611b1b565b9150611bf883611b1b565b92508282039050677fffffffffffffff81137fffffffffffffffffffffffffffffffffffffffffffffffff800000000000000082121715611c3c57611c3b6119bd565b5b92915050565b5f611c4c8261130c565b9150611c578361130c565b925082820390508181125f8412168282135f851215161715611c7c57611c7b6119bd565b5b92915050565b5f82825260208201905092915050565b7f496e646578206f7574206f6620626f756e6473000000000000000000000000005f82015250565b5f611cc6601383611c82565b9150611cd182611c92565b602082019050919050565b5f6020820190508181035f830152611cf381611cba565b905091905056fea26469706673582212203199a19f9e376057fd71e884f7483f4a6a7891bdafa101f0e4ea71cf71190cba64736f6c63430008160033"
        }
      }
    }
  },
  "modules": {
    "/Users/matt/dev/phaser-platformer/src/contracts/VerletSolver.s.sol": {
      "id": "/Users/matt/dev/phaser-platformer/src/contracts/VerletSolver.s.sol",
      "rawCode": "pragma solidity ^0.8.0;\nimport './ABDKMath64x64.sol';\n\ncontract VerletSolver {\n    struct Vector {\n        int x;\n        int y;\n    }\n\n    struct VectorInt128 {\n        int128 x;\n        int128 y;\n    }\n\n    struct VerletObject {\n        Vector position_current;\n        Vector position_old;\n        Vector acceleration;\n        uint radius;\n    }\n\n    struct Mass {\n        Vector position;\n        int mass;\n        int radius;\n    }\n\n    //a public function that takes in a verlet object and updates its position\n    function updatePosition(VerletObject memory obj, int dt) public pure returns (VerletObject memory) {\n        Vector memory velocity = Vector(\n            obj.position_current.x - obj.position_old.x,\n            obj.position_current.y - obj.position_old.y\n        );\n        obj.position_old = obj.position_current;\n        obj.position_current.x = obj.position_current.x + velocity.x + obj.acceleration.x * dt * dt;\n        obj.position_current.y = obj.position_current.y + velocity.y + obj.acceleration.y * dt * dt;\n\n        //obj.acceleration.x = 0;\n        //obj.acceleration.y = 0;\n\n        return obj;\n    }\n\n    function tick(\n        VerletObject memory obj,\n        Mass[] memory bodies,\n        int dt\n    ) public pure returns (VerletObject memory, Vector memory, Mass[] memory) {\n        obj = applyGravity(obj, 1);\n\n        Vector memory contactPoint;\n        bool collision;\n\n        (obj, contactPoint) = applyConstraintsCircularContainer(obj);\n\n        (obj, bodies, collision) = applyConstraintsPachinko(obj, bodies);\n        if(collision) {\n            contactPoint = Vector(-100, -100);\n        }\n        obj = updatePosition(obj, dt);\n\n        return (obj, contactPoint, bodies);\n    }\n\n    function applyGravitationalBodies(\n        VerletObject memory obj,\n        Mass[] memory bodies\n    ) public pure returns (VerletObject memory) {\n        for (uint i = 0; i < bodies.length; i++) {\n            Vector memory bodyPosition = bodies[i].position;\n            int bodyMass = bodies[i].mass;\n\n            int128 posX = ABDKMath64x64.fromInt(obj.position_current.x);\n            int128 posY = ABDKMath64x64.fromInt(obj.position_current.y);\n            int128 centerX = ABDKMath64x64.fromInt(bodyPosition.x);\n            int128 centerY = ABDKMath64x64.fromInt(bodyPosition.y);\n\n            int128 distance = getDistance(posX, posY, centerX, centerX);\n            int128 force = ABDKMath64x64.div(ABDKMath64x64.fromInt(bodyMass), ABDKMath64x64.mul(distance, distance));\n            int128 nX = ABDKMath64x64.div(ABDKMath64x64.sub(centerX, posX), distance);\n            int128 nY = ABDKMath64x64.div(ABDKMath64x64.sub(centerY, posY), distance);\n\n            obj.acceleration.x += ABDKMath64x64.toInt(ABDKMath64x64.mul(force, nX));\n            obj.acceleration.y += ABDKMath64x64.toInt(ABDKMath64x64.mul(force, nY));\n        }\n\n        return obj;\n    }\n\n    function accelerate(VerletObject memory obj, Vector memory acceleration) public pure returns (VerletObject memory) {\n        obj.acceleration.x = acceleration.x;\n        obj.acceleration.y = acceleration.y;\n        return obj;\n    }\n\n    function applyGravity(VerletObject memory obj, int gravity) public pure returns (VerletObject memory) {\n        obj.acceleration.y += gravity;\n        return obj;\n    }\n\n    struct CollisionData64x64 {\n        VectorInt128 pos;\n        VectorInt128 center;\n    }\n\n    struct CollisionAdjustment {\n        int128 newX;\n        int128 newY;\n        int128 nX;\n        int128 nY;\n    }\n\n    function applyConstraintsPachinko(\n        VerletObject memory obj,\n        Mass[] memory pegs     \n    ) public pure returns (VerletObject memory, Mass[] memory, bool) {\n        bool collision = false;\n\n        for (uint i = 0; i < pegs.length; i++) {\n            Vector memory pegPosition = pegs[i].position;\n            uint pegRadius = uint(pegs[i].radius);\n\n            CollisionData64x64 memory collisionData = CollisionData64x64(\n                VectorInt128(ABDKMath64x64.fromInt(obj.position_current.x), ABDKMath64x64.fromInt(obj.position_current.y)),\n                VectorInt128(ABDKMath64x64.fromInt(pegPosition.x), ABDKMath64x64.fromInt(pegPosition.y))\n            );\n\n            uint objRadius = obj.radius;\n            int128 distance = getDistance(collisionData.pos.x, collisionData.pos.y, collisionData.center.x, collisionData.center.y);\n            //If distance of object is less then radius of peg plus radius of object\n            if (distance < ABDKMath64x64.fromUInt(pegRadius + obj.radius) && !collision) {\n                collision = true;\n                //int nX = (obj.position_current.x - center.x) / int(distance);\n                \n                (CollisionAdjustment memory collisionAdjustment) = unstick64x64(\n                    collisionData.center.x,\n                    collisionData.center.y,\n                    collisionData.pos.x,\n                    collisionData.pos.y,\n                    distance,\n                    pegRadius,\n                    objRadius\n                );\n                obj.position_current.x = ABDKMath64x64.toInt(collisionAdjustment.newX);\n                obj.position_current.y = ABDKMath64x64.toInt(collisionAdjustment.newY);\n\n                //Acceleration becomes the normal line of the collision \n                obj.acceleration.x = -ABDKMath64x64.toInt(collisionAdjustment.nX) * int((90 - obj.radius) / 30);\n                obj.acceleration.y = ABDKMath64x64.toInt(collisionAdjustment.nY) - 15;\n\n                //Remove the peg that was hit from the array\n                pegs = removeItem(pegs, i);\n            }\n        }\n        return (obj, pegs, collision);\n    }\n\n    //Given a collision between two objects, return the new position of the object after the collision\n    function unstick64x64(\n        int128 centerX,\n        int128 centerY,\n        int128 posX,\n        int128 posY,\n        int128 distance,\n        uint collisionObjectMass,\n        uint objectRadius\n    ) internal pure returns (CollisionAdjustment memory) {\n        int128 nX = ABDKMath64x64.div(ABDKMath64x64.sub(centerX, posX), distance);\n        int128 nY = ABDKMath64x64.div(ABDKMath64x64.sub(centerY, posY), distance);\n\n        int128 newX = ABDKMath64x64.sub(\n            centerX,\n            ABDKMath64x64.mul(nX, ABDKMath64x64.fromUInt(collisionObjectMass + objectRadius))\n        );\n        int128 newY = ABDKMath64x64.sub(\n            centerY,\n            ABDKMath64x64.mul(nY, ABDKMath64x64.fromUInt(collisionObjectMass + objectRadius))\n        );\n\n        return CollisionAdjustment(newX, newY, nX, nY);\n    }\n\n    function removeItem(Mass[] memory array, uint index) internal pure returns (Mass[] memory) {\n        require(index < array.length, 'Index out of bounds');\n\n        Mass[] memory newArray = new Mass[](array.length);\n\n        for (uint i = 0; i < newArray.length; i++) {\n            if (i != index) {\n                newArray[i] = array[i];\n            }\n        }\n\n        return newArray;\n    }\n\n    //apply constraints using floating point math\n    function applyConstraintsCircularContainer(\n        VerletObject memory obj\n    ) public pure returns (VerletObject memory, Vector memory) {\n        int128 centerX = ABDKMath64x64.fromInt(1280 / 4);\n        int128 centerY = ABDKMath64x64.fromInt(360);\n\n        int128 boundaryRadius = ABDKMath64x64.fromUInt(320);\n        int128 objRadius = ABDKMath64x64.fromUInt(obj.radius);\n\n        int128 posX = ABDKMath64x64.fromInt(obj.position_current.x);\n        int128 posY = ABDKMath64x64.fromInt(obj.position_current.y);\n\n        int128 distance = getDistance(posX, posY, centerX, centerX);\n\n        Vector memory contactPoint;\n        if (distance > ABDKMath64x64.sub(boundaryRadius, objRadius)) {\n            //int nX = (obj.position_current.x - center.x) / int(distance);\n            int128 nX = ABDKMath64x64.div(ABDKMath64x64.sub(centerX, posX), distance);\n            int128 nY = ABDKMath64x64.div(ABDKMath64x64.sub(centerY, posY), distance);\n\n            int128 newX = ABDKMath64x64.sub(\n                centerX,\n                ABDKMath64x64.mul(nX, ABDKMath64x64.sub(boundaryRadius, objRadius))\n            );\n            int128 newY = ABDKMath64x64.sub(\n                centerY,\n                ABDKMath64x64.mul(nY, ABDKMath64x64.sub(boundaryRadius, objRadius))\n            );\n            obj.position_current.x = ABDKMath64x64.toInt(newX);\n            obj.position_current.y = ABDKMath64x64.toInt(newY);\n\n            //Acceleration becomes the normal line of the collision\n\n            obj.acceleration.x = ABDKMath64x64.toInt(nX);\n            obj.acceleration.y = ABDKMath64x64.toInt(nY);\n\n            if (obj.radius <= 10) {\n                obj.radius = obj.radius + 1;\n            } else {\n                obj.radius = obj.radius - 1;\n            }\n\n            contactPoint = Vector(ABDKMath64x64.toInt(posX), ABDKMath64x64.toInt(posY));\n        } else {\n            contactPoint = Vector(0, 0);\n        }\n\n        return (obj, contactPoint);\n    }\n\n    function getDistance(\n        int128 positionX,\n        int128 positionY,\n        int128 centerX,\n        int128 centerY\n    ) public pure returns (int128) {\n        int128 dx = getDistanceOnAxis(positionX, centerX);\n        int128 dy = getDistanceOnAxis(positionY, centerY);\n\n        int128 combined = ABDKMath64x64.add(ABDKMath64x64.mul(dx, dx), ABDKMath64x64.mul(dy, dy));\n        return ABDKMath64x64.sqrt(combined);\n    }\n\n    function getDistanceOnAxis(int128 x1, int128 x2) public pure returns (int128) {\n        int128 dx;\n        if (x1 < x2 && x1 > 0) {\n            dx = ABDKMath64x64.sub(x2, x1);\n        } else if (x1 > x2) {\n            dx = ABDKMath64x64.sub(x1, x2);\n        } else if (x1 < 0) {\n            dx = ABDKMath64x64.add(ABDKMath64x64.abs(x1), x2);\n        }\n        return dx;\n    }\n}\n",
      "importedIds": [
        "/Users/matt/dev/phaser-platformer/src/contracts/ABDKMath64x64.sol"
      ],
      "code": "pragma solidity >=0.8.0;\nimport '/Users/matt/dev/phaser-platformer/src/contracts/ABDKMath64x64.sol';\n\ncontract VerletSolver {\n    struct Vector {\n        int x;\n        int y;\n    }\n\n    struct VectorInt128 {\n        int128 x;\n        int128 y;\n    }\n\n    struct VerletObject {\n        Vector position_current;\n        Vector position_old;\n        Vector acceleration;\n        uint radius;\n    }\n\n    struct Mass {\n        Vector position;\n        int mass;\n        int radius;\n    }\n\n    //a public function that takes in a verlet object and updates its position\n    function updatePosition(VerletObject memory obj, int dt) public pure returns (VerletObject memory) {\n        Vector memory velocity = Vector(\n            obj.position_current.x - obj.position_old.x,\n            obj.position_current.y - obj.position_old.y\n        );\n        obj.position_old = obj.position_current;\n        obj.position_current.x = obj.position_current.x + velocity.x + obj.acceleration.x * dt * dt;\n        obj.position_current.y = obj.position_current.y + velocity.y + obj.acceleration.y * dt * dt;\n\n        //obj.acceleration.x = 0;\n        //obj.acceleration.y = 0;\n\n        return obj;\n    }\n\n    function tick(\n        VerletObject memory obj,\n        Mass[] memory bodies,\n        int dt\n    ) public pure returns (VerletObject memory, Vector memory, Mass[] memory) {\n        obj = applyGravity(obj, 1);\n\n        Vector memory contactPoint;\n        bool collision;\n\n        (obj, contactPoint) = applyConstraintsCircularContainer(obj);\n\n        (obj, bodies, collision) = applyConstraintsPachinko(obj, bodies);\n        if(collision) {\n            contactPoint = Vector(-100, -100);\n        }\n        obj = updatePosition(obj, dt);\n\n        return (obj, contactPoint, bodies);\n    }\n\n    function applyGravitationalBodies(\n        VerletObject memory obj,\n        Mass[] memory bodies\n    ) public pure returns (VerletObject memory) {\n        for (uint i = 0; i < bodies.length; i++) {\n            Vector memory bodyPosition = bodies[i].position;\n            int bodyMass = bodies[i].mass;\n\n            int128 posX = ABDKMath64x64.fromInt(obj.position_current.x);\n            int128 posY = ABDKMath64x64.fromInt(obj.position_current.y);\n            int128 centerX = ABDKMath64x64.fromInt(bodyPosition.x);\n            int128 centerY = ABDKMath64x64.fromInt(bodyPosition.y);\n\n            int128 distance = getDistance(posX, posY, centerX, centerX);\n            int128 force = ABDKMath64x64.div(ABDKMath64x64.fromInt(bodyMass), ABDKMath64x64.mul(distance, distance));\n            int128 nX = ABDKMath64x64.div(ABDKMath64x64.sub(centerX, posX), distance);\n            int128 nY = ABDKMath64x64.div(ABDKMath64x64.sub(centerY, posY), distance);\n\n            obj.acceleration.x += ABDKMath64x64.toInt(ABDKMath64x64.mul(force, nX));\n            obj.acceleration.y += ABDKMath64x64.toInt(ABDKMath64x64.mul(force, nY));\n        }\n\n        return obj;\n    }\n\n    function accelerate(VerletObject memory obj, Vector memory acceleration) public pure returns (VerletObject memory) {\n        obj.acceleration.x = acceleration.x;\n        obj.acceleration.y = acceleration.y;\n        return obj;\n    }\n\n    function applyGravity(VerletObject memory obj, int gravity) public pure returns (VerletObject memory) {\n        obj.acceleration.y += gravity;\n        return obj;\n    }\n\n    struct CollisionData64x64 {\n        VectorInt128 pos;\n        VectorInt128 center;\n    }\n\n    struct CollisionAdjustment {\n        int128 newX;\n        int128 newY;\n        int128 nX;\n        int128 nY;\n    }\n\n    function applyConstraintsPachinko(\n        VerletObject memory obj,\n        Mass[] memory pegs     \n    ) public pure returns (VerletObject memory, Mass[] memory, bool) {\n        bool collision = false;\n\n        for (uint i = 0; i < pegs.length; i++) {\n            Vector memory pegPosition = pegs[i].position;\n            uint pegRadius = uint(pegs[i].radius);\n\n            CollisionData64x64 memory collisionData = CollisionData64x64(\n                VectorInt128(ABDKMath64x64.fromInt(obj.position_current.x), ABDKMath64x64.fromInt(obj.position_current.y)),\n                VectorInt128(ABDKMath64x64.fromInt(pegPosition.x), ABDKMath64x64.fromInt(pegPosition.y))\n            );\n\n            uint objRadius = obj.radius;\n            int128 distance = getDistance(collisionData.pos.x, collisionData.pos.y, collisionData.center.x, collisionData.center.y);\n            //If distance of object is less then radius of peg plus radius of object\n            if (distance < ABDKMath64x64.fromUInt(pegRadius + obj.radius) && !collision) {\n                collision = true;\n                //int nX = (obj.position_current.x - center.x) / int(distance);\n                \n                (CollisionAdjustment memory collisionAdjustment) = unstick64x64(\n                    collisionData.center.x,\n                    collisionData.center.y,\n                    collisionData.pos.x,\n                    collisionData.pos.y,\n                    distance,\n                    pegRadius,\n                    objRadius\n                );\n                obj.position_current.x = ABDKMath64x64.toInt(collisionAdjustment.newX);\n                obj.position_current.y = ABDKMath64x64.toInt(collisionAdjustment.newY);\n\n                //Acceleration becomes the normal line of the collision \n                obj.acceleration.x = -ABDKMath64x64.toInt(collisionAdjustment.nX) * int((90 - obj.radius) / 30);\n                obj.acceleration.y = ABDKMath64x64.toInt(collisionAdjustment.nY) - 15;\n\n                //Remove the peg that was hit from the array\n                pegs = removeItem(pegs, i);\n            }\n        }\n        return (obj, pegs, collision);\n    }\n\n    //Given a collision between two objects, return the new position of the object after the collision\n    function unstick64x64(\n        int128 centerX,\n        int128 centerY,\n        int128 posX,\n        int128 posY,\n        int128 distance,\n        uint collisionObjectMass,\n        uint objectRadius\n    ) internal pure returns (CollisionAdjustment memory) {\n        int128 nX = ABDKMath64x64.div(ABDKMath64x64.sub(centerX, posX), distance);\n        int128 nY = ABDKMath64x64.div(ABDKMath64x64.sub(centerY, posY), distance);\n\n        int128 newX = ABDKMath64x64.sub(\n            centerX,\n            ABDKMath64x64.mul(nX, ABDKMath64x64.fromUInt(collisionObjectMass + objectRadius))\n        );\n        int128 newY = ABDKMath64x64.sub(\n            centerY,\n            ABDKMath64x64.mul(nY, ABDKMath64x64.fromUInt(collisionObjectMass + objectRadius))\n        );\n\n        return CollisionAdjustment(newX, newY, nX, nY);\n    }\n\n    function removeItem(Mass[] memory array, uint index) internal pure returns (Mass[] memory) {\n        require(index < array.length, 'Index out of bounds');\n\n        Mass[] memory newArray = new Mass[](array.length);\n\n        for (uint i = 0; i < newArray.length; i++) {\n            if (i != index) {\n                newArray[i] = array[i];\n            }\n        }\n\n        return newArray;\n    }\n\n    //apply constraints using floating point math\n    function applyConstraintsCircularContainer(\n        VerletObject memory obj\n    ) public pure returns (VerletObject memory, Vector memory) {\n        int128 centerX = ABDKMath64x64.fromInt(1280 / 4);\n        int128 centerY = ABDKMath64x64.fromInt(360);\n\n        int128 boundaryRadius = ABDKMath64x64.fromUInt(320);\n        int128 objRadius = ABDKMath64x64.fromUInt(obj.radius);\n\n        int128 posX = ABDKMath64x64.fromInt(obj.position_current.x);\n        int128 posY = ABDKMath64x64.fromInt(obj.position_current.y);\n\n        int128 distance = getDistance(posX, posY, centerX, centerX);\n\n        Vector memory contactPoint;\n        if (distance > ABDKMath64x64.sub(boundaryRadius, objRadius)) {\n            //int nX = (obj.position_current.x - center.x) / int(distance);\n            int128 nX = ABDKMath64x64.div(ABDKMath64x64.sub(centerX, posX), distance);\n            int128 nY = ABDKMath64x64.div(ABDKMath64x64.sub(centerY, posY), distance);\n\n            int128 newX = ABDKMath64x64.sub(\n                centerX,\n                ABDKMath64x64.mul(nX, ABDKMath64x64.sub(boundaryRadius, objRadius))\n            );\n            int128 newY = ABDKMath64x64.sub(\n                centerY,\n                ABDKMath64x64.mul(nY, ABDKMath64x64.sub(boundaryRadius, objRadius))\n            );\n            obj.position_current.x = ABDKMath64x64.toInt(newX);\n            obj.position_current.y = ABDKMath64x64.toInt(newY);\n\n            //Acceleration becomes the normal line of the collision\n\n            obj.acceleration.x = ABDKMath64x64.toInt(nX);\n            obj.acceleration.y = ABDKMath64x64.toInt(nY);\n\n            if (obj.radius <= 10) {\n                obj.radius = obj.radius + 1;\n            } else {\n                obj.radius = obj.radius - 1;\n            }\n\n            contactPoint = Vector(ABDKMath64x64.toInt(posX), ABDKMath64x64.toInt(posY));\n        } else {\n            contactPoint = Vector(0, 0);\n        }\n\n        return (obj, contactPoint);\n    }\n\n    function getDistance(\n        int128 positionX,\n        int128 positionY,\n        int128 centerX,\n        int128 centerY\n    ) public pure returns (int128) {\n        int128 dx = getDistanceOnAxis(positionX, centerX);\n        int128 dy = getDistanceOnAxis(positionY, centerY);\n\n        int128 combined = ABDKMath64x64.add(ABDKMath64x64.mul(dx, dx), ABDKMath64x64.mul(dy, dy));\n        return ABDKMath64x64.sqrt(combined);\n    }\n\n    function getDistanceOnAxis(int128 x1, int128 x2) public pure returns (int128) {\n        int128 dx;\n        if (x1 < x2 && x1 > 0) {\n            dx = ABDKMath64x64.sub(x2, x1);\n        } else if (x1 > x2) {\n            dx = ABDKMath64x64.sub(x1, x2);\n        } else if (x1 < 0) {\n            dx = ABDKMath64x64.add(ABDKMath64x64.abs(x1), x2);\n        }\n        return dx;\n    }\n}\n"
    },
    "/Users/matt/dev/phaser-platformer/src/contracts/ABDKMath64x64.sol": {
      "id": "/Users/matt/dev/phaser-platformer/src/contracts/ABDKMath64x64.sol",
      "rawCode": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /*\n   * Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /*\n   * Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (x << 64);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    unchecked {\n      return int64 (x >> 64);\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    unchecked {\n      require (x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (int256 (x << 64));\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    unchecked {\n      require (x >= 0);\n      return uint64 (uint128 (x >> 64));\n    }\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    unchecked {\n      int256 result = x >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    unchecked {\n      return int256 (x) << 64;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) + y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) - y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) * y >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    unchecked {\n      if (x == MIN_64x64) {\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n          y <= 0x1000000000000000000000000000000000000000000000000);\n        return -y << 63;\n      } else {\n        bool negativeResult = false;\n        if (x < 0) {\n          x = -x;\n          negativeResult = true;\n        }\n        if (y < 0) {\n          y = -y; // We rely on overflow behavior here\n          negativeResult = !negativeResult;\n        }\n        uint256 absoluteResult = mulu (x, uint256 (y));\n        if (negativeResult) {\n          require (absoluteResult <=\n            0x8000000000000000000000000000000000000000000000000000000000000000);\n          return -int256 (absoluteResult); // We rely on overflow behavior here\n        } else {\n          require (absoluteResult <=\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n          return int256 (absoluteResult);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    unchecked {\n      if (y == 0) return 0;\n\n      require (x >= 0);\n\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\n\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      hi <<= 64;\n\n      require (hi <=\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n      return hi + lo;\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      int256 result = (int256 (x) << 64) / y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x; // We rely on overflow behavior here\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <= 0x80000000000000000000000000000000);\n        return -int128 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128 (absoluteResult); // We rely on overflow behavior here\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      uint128 result = divuu (x, y);\n      require (result <= uint128 (MAX_64x64));\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return -x;\n    }\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return x < 0 ? -x : x;\n    }\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != 0);\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      return int128 ((int256 (x) + int256 (y)) >> 1);\n    }\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 m = int256 (x) * int256 (y);\n      require (m >= 0);\n      require (m <\n          0x4000000000000000000000000000000000000000000000000000000000000000);\n      return int128 (sqrtu (uint256 (m)));\n    }\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      bool negative = x < 0 && y & 1 == 1;\n\n      uint256 absX = uint128 (x < 0 ? -x : x);\n      uint256 absResult;\n      absResult = 0x100000000000000000000000000000000;\n\n      if (absX <= 0x10000000000000000) {\n        absX <<= 63;\n        while (y != 0) {\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x2 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x4 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x8 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          y >>= 4;\n        }\n\n        absResult >>= 64;\n      } else {\n        uint256 absXShift = 63;\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\n\n        uint256 resultShift = 0;\n        while (y != 0) {\n          require (absXShift < 64);\n\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n            resultShift += absXShift;\n            if (absResult > 0x100000000000000000000000000000000) {\n              absResult >>= 1;\n              resultShift += 1;\n            }\n          }\n          absX = absX * absX >> 127;\n          absXShift <<= 1;\n          if (absX >= 0x100000000000000000000000000000000) {\n              absX >>= 1;\n              absXShift += 1;\n          }\n\n          y >>= 1;\n        }\n\n        require (resultShift < 64);\n        absResult >>= 64 - resultShift;\n      }\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= 0);\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      int256 msb = 0;\n      int256 xc = x;\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 result = msb - 64 << 64;\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n        ux *= ux;\n        uint256 b = ux >> 255;\n        ux >>= 127 + b;\n        result += bit * int256 (b);\n      }\n\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      return int128 (int256 (\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\n    }\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      uint256 result = 0x80000000000000000000000000000000;\n\n      if (x & 0x8000000000000000 > 0)\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n      if (x & 0x4000000000000000 > 0)\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n      if (x & 0x2000000000000000 > 0)\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n      if (x & 0x1000000000000000 > 0)\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n      if (x & 0x800000000000000 > 0)\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n      if (x & 0x400000000000000 > 0)\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n      if (x & 0x200000000000000 > 0)\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n      if (x & 0x100000000000000 > 0)\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n      if (x & 0x80000000000000 > 0)\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n      if (x & 0x40000000000000 > 0)\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n      if (x & 0x20000000000000 > 0)\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n      if (x & 0x10000000000000 > 0)\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n      if (x & 0x8000000000000 > 0)\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n      if (x & 0x4000000000000 > 0)\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n      if (x & 0x2000000000000 > 0)\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n      if (x & 0x1000000000000 > 0)\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n      if (x & 0x800000000000 > 0)\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n      if (x & 0x400000000000 > 0)\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n      if (x & 0x200000000000 > 0)\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n      if (x & 0x100000000000 > 0)\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n      if (x & 0x80000000000 > 0)\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n      if (x & 0x40000000000 > 0)\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n      if (x & 0x20000000000 > 0)\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n      if (x & 0x10000000000 > 0)\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n      if (x & 0x8000000000 > 0)\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n      if (x & 0x4000000000 > 0)\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n      if (x & 0x2000000000 > 0)\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n      if (x & 0x1000000000 > 0)\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n      if (x & 0x800000000 > 0)\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n      if (x & 0x400000000 > 0)\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n      if (x & 0x200000000 > 0)\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n      if (x & 0x100000000 > 0)\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n      if (x & 0x80000000 > 0)\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n      if (x & 0x40000000 > 0)\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n      if (x & 0x20000000 > 0)\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n      if (x & 0x10000000 > 0)\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n      if (x & 0x8000000 > 0)\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n      if (x & 0x4000000 > 0)\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n      if (x & 0x2000000 > 0)\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n      if (x & 0x1000000 > 0)\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n      if (x & 0x800000 > 0)\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n      if (x & 0x400000 > 0)\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n      if (x & 0x200000 > 0)\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n      if (x & 0x100000 > 0)\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n      if (x & 0x80000 > 0)\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n      if (x & 0x40000 > 0)\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n      if (x & 0x20000 > 0)\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n      if (x & 0x10000 > 0)\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n      if (x & 0x8000 > 0)\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n      if (x & 0x4000 > 0)\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n      if (x & 0x2000 > 0)\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n      if (x & 0x1000 > 0)\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n      if (x & 0x800 > 0)\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n      if (x & 0x400 > 0)\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n      if (x & 0x200 > 0)\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n      if (x & 0x100 > 0)\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n      if (x & 0x80 > 0)\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n      if (x & 0x40 > 0)\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n      if (x & 0x20 > 0)\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n      if (x & 0x10 > 0)\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n      if (x & 0x8 > 0)\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n      if (x & 0x4 > 0)\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n      if (x & 0x2 > 0)\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n      if (x & 0x1 > 0)\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n      result >>= uint256 (int256 (63 - (x >> 64)));\n      require (result <= uint256 (int256 (MAX_64x64)));\n\n      return int128 (int256 (result));\n    }\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      return exp_2 (\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    unchecked {\n      require (y != 0);\n\n      uint256 result;\n\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        result = (x << 64) / y;\n      else {\n        uint256 msb = 192;\n        uint256 xc = x >> 192;\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 hi = result * (y >> 128);\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 xh = x >> 192;\n        uint256 xl = x << 64;\n\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n        lo = hi << 128;\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n\n        result += xh == hi >> 128 ? xl / y : 1;\n      }\n\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return uint128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x) private pure returns (uint128) {\n    unchecked {\n      if (x == 0) return 0;\n      else {\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n        if (xx >= 0x4) { r <<= 1; }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return uint128 (r < r1 ? r : r1);\n      }\n    }\n  }\n}",
      "importedIds": [],
      "code": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity >=0.8.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /*\n   * Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /*\n   * Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (x << 64);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    unchecked {\n      return int64 (x >> 64);\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    unchecked {\n      require (x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (int256 (x << 64));\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    unchecked {\n      require (x >= 0);\n      return uint64 (uint128 (x >> 64));\n    }\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    unchecked {\n      int256 result = x >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    unchecked {\n      return int256 (x) << 64;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) + y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) - y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) * y >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    unchecked {\n      if (x == MIN_64x64) {\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n          y <= 0x1000000000000000000000000000000000000000000000000);\n        return -y << 63;\n      } else {\n        bool negativeResult = false;\n        if (x < 0) {\n          x = -x;\n          negativeResult = true;\n        }\n        if (y < 0) {\n          y = -y; // We rely on overflow behavior here\n          negativeResult = !negativeResult;\n        }\n        uint256 absoluteResult = mulu (x, uint256 (y));\n        if (negativeResult) {\n          require (absoluteResult <=\n            0x8000000000000000000000000000000000000000000000000000000000000000);\n          return -int256 (absoluteResult); // We rely on overflow behavior here\n        } else {\n          require (absoluteResult <=\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n          return int256 (absoluteResult);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    unchecked {\n      if (y == 0) return 0;\n\n      require (x >= 0);\n\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\n\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      hi <<= 64;\n\n      require (hi <=\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n      return hi + lo;\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      int256 result = (int256 (x) << 64) / y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x; // We rely on overflow behavior here\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <= 0x80000000000000000000000000000000);\n        return -int128 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128 (absoluteResult); // We rely on overflow behavior here\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      uint128 result = divuu (x, y);\n      require (result <= uint128 (MAX_64x64));\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return -x;\n    }\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return x < 0 ? -x : x;\n    }\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != 0);\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      return int128 ((int256 (x) + int256 (y)) >> 1);\n    }\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 m = int256 (x) * int256 (y);\n      require (m >= 0);\n      require (m <\n          0x4000000000000000000000000000000000000000000000000000000000000000);\n      return int128 (sqrtu (uint256 (m)));\n    }\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      bool negative = x < 0 && y & 1 == 1;\n\n      uint256 absX = uint128 (x < 0 ? -x : x);\n      uint256 absResult;\n      absResult = 0x100000000000000000000000000000000;\n\n      if (absX <= 0x10000000000000000) {\n        absX <<= 63;\n        while (y != 0) {\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x2 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x4 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x8 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          y >>= 4;\n        }\n\n        absResult >>= 64;\n      } else {\n        uint256 absXShift = 63;\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\n\n        uint256 resultShift = 0;\n        while (y != 0) {\n          require (absXShift < 64);\n\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n            resultShift += absXShift;\n            if (absResult > 0x100000000000000000000000000000000) {\n              absResult >>= 1;\n              resultShift += 1;\n            }\n          }\n          absX = absX * absX >> 127;\n          absXShift <<= 1;\n          if (absX >= 0x100000000000000000000000000000000) {\n              absX >>= 1;\n              absXShift += 1;\n          }\n\n          y >>= 1;\n        }\n\n        require (resultShift < 64);\n        absResult >>= 64 - resultShift;\n      }\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= 0);\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      int256 msb = 0;\n      int256 xc = x;\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 result = msb - 64 << 64;\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n        ux *= ux;\n        uint256 b = ux >> 255;\n        ux >>= 127 + b;\n        result += bit * int256 (b);\n      }\n\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      return int128 (int256 (\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\n    }\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      uint256 result = 0x80000000000000000000000000000000;\n\n      if (x & 0x8000000000000000 > 0)\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n      if (x & 0x4000000000000000 > 0)\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n      if (x & 0x2000000000000000 > 0)\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n      if (x & 0x1000000000000000 > 0)\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n      if (x & 0x800000000000000 > 0)\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n      if (x & 0x400000000000000 > 0)\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n      if (x & 0x200000000000000 > 0)\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n      if (x & 0x100000000000000 > 0)\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n      if (x & 0x80000000000000 > 0)\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n      if (x & 0x40000000000000 > 0)\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n      if (x & 0x20000000000000 > 0)\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n      if (x & 0x10000000000000 > 0)\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n      if (x & 0x8000000000000 > 0)\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n      if (x & 0x4000000000000 > 0)\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n      if (x & 0x2000000000000 > 0)\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n      if (x & 0x1000000000000 > 0)\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n      if (x & 0x800000000000 > 0)\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n      if (x & 0x400000000000 > 0)\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n      if (x & 0x200000000000 > 0)\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n      if (x & 0x100000000000 > 0)\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n      if (x & 0x80000000000 > 0)\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n      if (x & 0x40000000000 > 0)\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n      if (x & 0x20000000000 > 0)\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n      if (x & 0x10000000000 > 0)\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n      if (x & 0x8000000000 > 0)\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n      if (x & 0x4000000000 > 0)\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n      if (x & 0x2000000000 > 0)\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n      if (x & 0x1000000000 > 0)\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n      if (x & 0x800000000 > 0)\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n      if (x & 0x400000000 > 0)\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n      if (x & 0x200000000 > 0)\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n      if (x & 0x100000000 > 0)\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n      if (x & 0x80000000 > 0)\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n      if (x & 0x40000000 > 0)\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n      if (x & 0x20000000 > 0)\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n      if (x & 0x10000000 > 0)\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n      if (x & 0x8000000 > 0)\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n      if (x & 0x4000000 > 0)\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n      if (x & 0x2000000 > 0)\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n      if (x & 0x1000000 > 0)\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n      if (x & 0x800000 > 0)\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n      if (x & 0x400000 > 0)\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n      if (x & 0x200000 > 0)\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n      if (x & 0x100000 > 0)\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n      if (x & 0x80000 > 0)\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n      if (x & 0x40000 > 0)\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n      if (x & 0x20000 > 0)\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n      if (x & 0x10000 > 0)\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n      if (x & 0x8000 > 0)\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n      if (x & 0x4000 > 0)\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n      if (x & 0x2000 > 0)\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n      if (x & 0x1000 > 0)\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n      if (x & 0x800 > 0)\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n      if (x & 0x400 > 0)\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n      if (x & 0x200 > 0)\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n      if (x & 0x100 > 0)\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n      if (x & 0x80 > 0)\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n      if (x & 0x40 > 0)\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n      if (x & 0x20 > 0)\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n      if (x & 0x10 > 0)\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n      if (x & 0x8 > 0)\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n      if (x & 0x4 > 0)\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n      if (x & 0x2 > 0)\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n      if (x & 0x1 > 0)\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n      result >>= uint256 (int256 (63 - (x >> 64)));\n      require (result <= uint256 (int256 (MAX_64x64)));\n\n      return int128 (int256 (result));\n    }\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      return exp_2 (\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    unchecked {\n      require (y != 0);\n\n      uint256 result;\n\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        result = (x << 64) / y;\n      else {\n        uint256 msb = 192;\n        uint256 xc = x >> 192;\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 hi = result * (y >> 128);\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 xh = x >> 192;\n        uint256 xl = x << 64;\n\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n        lo = hi << 128;\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n\n        result += xh == hi >> 128 ? xl / y : 1;\n      }\n\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return uint128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x) private pure returns (uint128) {\n    unchecked {\n      if (x == 0) return 0;\n      else {\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n        if (xx >= 0x4) { r <<= 1; }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return uint128 (r < r1 ? r : r1);\n      }\n    }\n  }\n}"
    }
  }
}